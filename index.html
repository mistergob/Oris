<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <title>ORIS</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Polices ATMOS -->
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700;900&family=Outfit:wght@300;400;600&display=swap" rel="stylesheet"/>

  <style>
    :root{
      --primary:#00eaff; --accent:#8a2be2; --text:#e6f7ff; --muted:#9fb3c8;
      --space-img:url("https://images.unsplash.com/photo-1444703686981-a3abbc4d4fe3?q=80&w=1920&auto=format&fit=crop");
      --bg-a:#05060d; --bg-b:#0b1430; --bg-c:#00182a;
      --glow: drop-shadow(0 0 8px rgba(0,234,255,.55)) drop-shadow(0 0 18px rgba(138,43,226,.35));
      --ring: 0 0 0 3px rgba(0,234,255,.35), 0 0 24px rgba(0,234,255,.25);
      --grid:rgba(255,255,255,.12);
      --glass: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      --card: rgba(8,12,28,.55);
      --ok:#16a34a; --warn:#f59e0b; --danger:#ef4444;
      --sidebar-w: 340px;
      --toolbar-h: 64px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;color:var(--text);
      font-family: Outfit, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background:
        radial-gradient(1200px 800px at 75% 10%, rgba(138,43,226,.18), transparent 60%),
        radial-gradient(900px 700px at 15% 85%, rgba(0,234,255,.12), transparent 55%),
        radial-gradient(700px 500px at 80% 80%, rgba(0,40,80,.35), transparent 60%),
        linear-gradient(120deg, var(--bg-a), var(--bg-b) 40%, var(--bg-c));
      overflow:hidden;
    }
    body::before{
      content:""; position:fixed; inset:0; pointer-events:none; mix-blend-mode:screen; opacity:.15; z-index:-1;
      background:
        var(--space-img) center/cover no-repeat,
        radial-gradient(1px 1px at 10% 20%, #fff 40%, transparent 41%),
        radial-gradient(1px 1px at 30% 80%, #fff 40%, transparent 41%),
        radial-gradient(1px 1px at 70% 30%, #fff 40%, transparent 41%),
        radial-gradient(1px 1px at 90% 60%, #fff 40%, transparent 41%);
      animation: twinkle 14s linear infinite;
    }
    @keyframes twinkle{0%,100%{opacity:.12}50%{opacity:.22}}
    body::after{content:""; position:fixed; inset:-10%; pointer-events:none; z-index:-1; filter:blur(24px);
      background: radial-gradient(600px 320px at 50% 25%, rgba(0,234,255,.18), transparent 60%),
                  radial-gradient(900px 420px at 50% 70%, rgba(138,43,226,.18), transparent 65%);
      animation: float 18s ease-in-out infinite alternate;
    }
    @keyframes float{from{transform:translateY(-1.5%)}to{transform:translateY(1.5%)}}

    .shell{display:grid; grid-template-columns: 1fr var(--sidebar-w); gap:12px; height:100vh; padding:12px; max-width:1600px; margin:0 auto}
    .main{display:flex; flex-direction:column; min-width:0}
    .right{display:flex; flex-direction:column; min-width:0}

    .topbar{
      height:var(--toolbar-h);
      display:flex; align-items:center; gap:10px;
      background:var(--glass); border:1px solid var(--grid); border-radius:16px; padding:10px 12px;
      box-shadow:0 12px 40px rgba(0,0,0,.35); backdrop-filter: blur(8px);
    }
    .topbar h1{margin:0 8px 0 4px; font:700 16px/1 Orbitron, sans-serif; letter-spacing:.06em}
    .spacer{flex:1}
    .btn{
      appearance:none; cursor:pointer; border:1px solid transparent; border-radius:12px; padding:10px 12px; color:var(--text);
      background: linear-gradient(#0c1327,#0b1120) padding-box,
                  conic-gradient(from 180deg, rgba(0,234,255,.8), rgba(138,43,226,.8), rgba(0,234,255,.8)) border-box;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.04), 0 8px 24px rgba(0,0,0,.45);
      transition: transform .2s ease, filter .2s ease, box-shadow .2s ease; font-weight:600; letter-spacing:.02em;
    }
    .btn:hover{ transform: translateY(-2px); filter: var(--glow); }
    .btn:focus-visible{ outline:none; box-shadow: var(--ring); }
    .btn.small{padding:6px 10px; border-radius:10px; font-size:12px}
    .btn.ghost{ background:transparent; border:1px solid var(--grid) }

    .input,.select{
      height:36px; border:1px solid var(--grid); border-radius:10px; background:rgba(8,12,28,.6); color:var(--text); padding:0 10px; outline:none;
    }
    .status{font-size:12px;color:var(--muted)}
    .bar{display:flex; align-items:center; gap:8px}

    /* Agenda container */
    .calendar-wrap{
      flex:1; min-height:0; margin-top:12px;
      background:var(--glass); border:1px solid var(--grid); border-radius:16px; padding:8px;
      box-shadow:0 12px 40px rgba(0,0,0,.35); backdrop-filter: blur(8px);
      display:flex; flex-direction:column; overflow:hidden;
    }
    .calendar-toolbar{display:flex; align-items:center; gap:8px; padding:6px 8px}
    .calendar-canvas{flex:1; min-height:0; border:1px solid var(--grid); border-radius:12px; background:var(--card); overflow:auto; position:relative}

    /* Simple month/week/day header */
    .seg{display:inline-flex; border:1px solid var(--grid); border-radius:10px; overflow:hidden}
    .seg button{border:0;background:transparent;color:var(--text);padding:6px 10px;cursor:pointer}
    .seg button.active{background:rgba(255,255,255,.08)}

    /* Event list in day/week/month grid (homemade) */
    .grid{display:grid; gap:6px; padding:8px}
    .grid.month{grid-template-columns:repeat(7,1fr)}
    .grid.week{grid-template-columns: 100px repeat(7,1fr)}
    .grid.day{grid-template-columns: 1fr}
    .cell{border:1px solid var(--grid); border-radius:10px; padding:8px; min-height:100px; background:rgba(255,255,255,.03)}
    .cell.head{min-height:auto; text-align:center; font-size:12px; color:var(--muted)}
    .event{margin:4px 0; padding:6px 8px; border:1px solid var(--grid); border-radius:8px; background:rgba(0,0,0,.25); font-size:12px; cursor:pointer}
    .event:hover{filter:var(--glow)}
    .when{opacity:.8; font-size:11px}

    /* Right panel: calendars + tasks */
    .panel{
      height:100%;
      display:grid; grid-template-rows: var(--toolbar-h) 1fr;
    }
    .panel-head{
      display:flex; align-items:center; gap:8px; background:var(--glass); border:1px solid var(--grid); border-radius:16px; padding:10px 12px;
      box-shadow:0 12px 40px rgba(0,0,0,.35); backdrop-filter: blur(8px);
    }
    .panel-body{
      margin-top:12px; background:var(--glass); border:1px solid var(--grid); border-radius:16px; padding:10px; overflow:auto;
      box-shadow:0 12px 40px rgba(0,0,0,.35); backdrop-filter: blur(8px);
    }
    .section{border:1px solid var(--grid); border-radius:12px; padding:10px; margin-bottom:10px; background:rgba(255,255,255,.03)}
    .section h3{margin:0 0 8px; font-family:Orbitron,sans-serif; letter-spacing:.06em; font-size:14px}
    .cal-item{display:flex; align-items:center; gap:8px; padding:6px 8px; border:1px solid var(--grid); border-radius:10px; margin:6px 0; background:rgba(0,0,0,.25); cursor:pointer}
    .cal-item input[type="checkbox"]{width:16px;height:16px;accent-color:var(--primary);cursor:pointer;flex:0 0 auto}
    .cal-item.cal-hidden{opacity:.45}
    .dot{width:10px;height:10px;border-radius:9999px;border:1px solid var(--grid);flex:0 0 auto}
    .task{display:flex; align-items:flex-start; gap:8px; border:1px solid var(--grid); border-radius:10px; padding:8px; margin:6px 0; background:rgba(0,0,0,.25)}
    .task small{color:var(--muted)}

    /* Modal event editor */
    .modal{position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(3,6,16,.55); z-index:50; backdrop-filter: blur(2px);}
    .modal .card{width:min(720px,calc(100vw - 24px)); background:var(--glass); border:1px solid var(--grid); border-radius:16px; padding:12px; box-shadow:0 20px 40px rgba(0,0,0,.35)}
    .row{display:flex; gap:8px}
    .row > *{flex:1}
    label{font-size:12px; color:var(--muted)}
    input, textarea, select{width:100%; background:rgba(0,0,0,.25); color:var(--text); border:1px solid var(--grid); border-radius:10px; padding:8px}
    textarea{min-height:96px; resize:vertical}

    /* AUTH LOCK */
    .auth-block{
      position:fixed; inset:0; display:none; align-items:center; justify-content:center;
      background:rgba(3,6,16,.65); backdrop-filter:blur(3px); z-index:9999;
    }
    .auth-card{
      width:min(520px,calc(100vw - 32px)); padding:16px; border-radius:16px;
      border:1px solid rgba(255,255,255,.06);
      background:var(--glass);
      box-shadow:0 20px 40px rgba(0,0,0,.45); color:var(--text);
    }
    .auth-card h3{ margin:0 0 8px; font-family:Orbitron,sans-serif; letter-spacing:.06em }

    body.auth-locked .auth-block{ display:flex; }
    body.auth-locked .shell{ pointer-events:none; filter:grayscale(1) opacity(.35) }
    @media (prefers-reduced-motion: reduce){ *{animation:none!important; transition:none!important} }
  </style>

  <!-- Google API -->
  <script>
    window.__gapiReady = false;
    window.__gapiError = null;
    async function onGapiLoad(){
      if (!window.gapi) { window.__gapiError = new Error('gapi non chargé'); return; }
      try{
        await new Promise(res => gapi.load('client', res));
        await gapi.client.init({ discoveryDocs: [
          'https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest'
        ]});
        window.__gapiReady = true;
        console.log('[ORIS] GAPI prêt (Calendar)');
      }catch(err){
        window.__gapiError = err;
        console.error('[ORIS] Erreur init GAPI:', err);
      }
    }
    function waitForGapiReady(timeoutMs=7000){
      return new Promise(resolve=>{
        if(window.__gapiReady) return resolve();
        const t0 = Date.now();
        const id = setInterval(()=>{
          if(window.__gapiReady || window.__gapiError || Date.now()-t0>timeoutMs){
            clearInterval(id); resolve();
          }
        }, 100);
      });
    }
  </script>
  <script src="https://apis.google.com/js/api.js?onload=onGapiLoad" async defer></script>
  <script src="https://accounts.google.com/gsi/client" async defer></script>
</head>

<body class="auth-locked">
  <div class="shell">
    <div class="main">
      <!-- TOPBAR -->
      <div class="topbar">
        <h1>Agenda — <span class="appname">ORIS</span></h1>
        <button class="btn small" id="googleBtn">Connecter Google</button>
        <button class="btn small ghost" id="logoutBtn" disabled>Déconnexion</button>
        <div class="spacer"></div>
        <div class="bar">
          <button class="btn small" id="prevBtn">◀</button>
          <button class="btn small" id="todayBtn">Aujourd’hui</button>
          <button class="btn small" id="nextBtn">▶</button>

          <div class="seg" role="tablist" aria-label="Vues">
            <button class="viewBtn active" data-view="month">Mois</button>
            <button class="viewBtn" data-view="week">Semaine</button>
            <button class="viewBtn" data-view="day">Jour</button>
          </div>

          <input id="searchInput" class="input" type="search" placeholder="Rechercher (titre, lieu…)" style="min-width:220px">
          <button id="searchBtn" class="btn small">Rechercher</button>
        </div>
      </div>

      <!-- AGENDA -->
      <div class="calendar-wrap">
        <div class="calendar-toolbar">
          <div class="bar">
            <select id="calendarSelect" class="select" title="Calendrier">
              <option value="">Tous les calendriers</option>
            </select>
            <button id="newEventBtn" class="btn small">+ Nouvel événement</button>
            <span id="status" class="status">Connexion requise.</span>
          </div>
          <div class="spacer"></div>
          <div class="bar">
            <span class="status" id="periodLabel">—</span>
          </div>
        </div>
        <div id="canvas" class="calendar-canvas">
          <div id="grid" class="grid month"></div>
        </div>
      </div>
    </div>

    <!-- RIGHT PANEL: Calendriers + Tâches (SPHAIRA) -->
    <div class="right panel">
      <div class="panel-head">
        <strong style="font-family:Orbitron">ORIS — Panneau</strong>
        <div class="spacer"></div>
        <button id="toggleTasks" class="btn small">Tâches</button>
        <button id="refreshBtn" class="btn small">Rafraîchir</button>
      </div>
      <div class="panel-body" id="sideBody">
        <div class="section" id="calendarsSection">
          <h3>Calendriers</h3>
          <div id="calList"></div>
        </div>
        <div class="section" id="tasksSection">
          <h3>Tâches (SPHAIRA)</h3>
          <div id="taskList">—</div>
          <div style="margin-top:6px" class="status">Source : SPHAIRA (localStorage).</div>
        </div>
      </div>
    </div>
  </div>

  <!-- EVENT EDITOR MODAL -->
  <div id="eventModal" class="modal" aria-hidden="true" role="dialog" aria-label="Édition événement">
    <div class="card">
      <div style="display:flex; align-items:center; justify-content:space-between; gap:8px">
        <h3 id="evtTitle">Nouvel événement</h3>
        <div class="bar">
          <button id="saveEventBtn" class="btn">Enregistrer</button>
          <button id="deleteEventBtn" class="btn ghost" style="display:none">Supprimer</button>
          <button id="closeEventBtn" class="btn">Fermer</button>
        </div>
      </div>
      <div class="row">
        <div>
          <label>Titre</label>
          <input id="fTitle" placeholder="Titre">
        </div>
        <div>
          <label>Calendrier</label>
          <select id="fCalendar"></select>
        </div>
      </div>
      <div class="row">
        <div>
          <label>Début</label>
          <input id="fStart" type="datetime-local">
        </div>
        <div>
          <label>Fin</label>
          <input id="fEnd" type="datetime-local">
        </div>
      </div>
      <div class="row">
        <div>
          <label>Lieu</label>
          <input id="fLocation" placeholder="Lieu">
        </div>
        <div>
          <label>Visio (Meet)</label>
          <select id="fMeet">
            <option value="">—</option>
            <option value="create">Créer un lien Meet</option>
          </select>
        </div>
      </div>
      <div>
        <label>Description</label>
        <textarea id="fDesc" placeholder="Détails"></textarea>
      </div>
    </div>
  </div>

  <!-- AUTH OVERLAY (SSO ATMOS) -->
  <div id="authBlock" class="auth-block" aria-live="polite" role="alert">
    <div class="auth-card">
      <h3>Connexion nécessaire</h3>
      <p>Connectez-vous sur <strong>ATMOS</strong> pour utiliser ORIS.</p>
      <div class="actions" style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
        <a id="authGoAtmos" class="btn">Se connecter sur ATMOS</a>
      </div>
    </div>
  </div>

  <!-- APP LOGIC -->
  <script>
    'use strict';

    // ====== CONFIG ======
    const GOOGLE_CLIENT_ID = "514694919456-u0csh5so13bsb8u0cl5a7fl5lgmla4c4.apps.googleusercontent.com";
    const CAL_SCOPES = 'https://www.googleapis.com/auth/calendar';

    // Supabase (SSO)
    const PROJECT_REF = "jlfvbggzdkkwrmpsamvz";
    const SUPABASE_URL = `https://${PROJECT_REF}.supabase.co`;
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImpsZnZiZ2d6ZGtrd3JtcHNhbXZ6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTcyNjUyNjMsImV4cCI6MjA3Mjg0MTI2M30.kDbtNVQfHEVxRbA8jsAfLu7-6kDioTCG-nWVQ91gJIs";
    const ATMOS_URL = "https://mistergob.github.io/Atmos/";
    const STORAGE_KEY = `sb-${PROJECT_REF}-auth-token`;

    // Heartbeat keys / intervals
    const ORIS_BEAT_KEY = 'oris:beatAt';
    const ORIS_BEAT_INTERVAL = 10000; // 10s
  </script>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script>
    // ====== STATE ======
    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
      auth: { persistSession:true, autoRefreshToken:true, detectSessionInUrl:true, storage: window.localStorage, storageKey: STORAGE_KEY }
    });

    const authGo = document.getElementById('authGoAtmos');
    if (authGo) authGo.href = ATMOS_URL + "?r=" + encodeURIComponent(location.href);

    const statusEl = document.getElementById('status');
    const periodLabel = document.getElementById('periodLabel');
    const gridEl = document.getElementById('grid');
    const canvas = document.getElementById('canvas');

    const viewBtns = Array.from(document.querySelectorAll('.viewBtn'));
    const calendarSelect = document.getElementById('calendarSelect');

    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const todayBtn = document.getElementById('todayBtn');
    const searchInput = document.getElementById('searchInput');
    const searchBtn = document.getElementById('searchBtn');
    const refreshBtn = document.getElementById('refreshBtn');

    const googleBtn = document.getElementById('googleBtn');
    const logoutBtn = document.getElementById('logoutBtn');

    const calListEl = document.getElementById('calList');
    const tasksSection = document.getElementById('tasksSection');
    const taskListEl = document.getElementById('taskList');
    const toggleTasksBtn = document.getElementById('toggleTasks');

    const eventModal = document.getElementById('eventModal');
    const evtTitle = document.getElementById('evtTitle');
    const fTitle = document.getElementById('fTitle');
    const fCalendar = document.getElementById('fCalendar');
    const fStart = document.getElementById('fStart');
    const fEnd = document.getElementById('fEnd');
    const fLocation = document.getElementById('fLocation');
    const fDesc = document.getElementById('fDesc');
    const fMeet = document.getElementById('fMeet');
    const saveEventBtn = document.getElementById('saveEventBtn');
    const deleteEventBtn = document.getElementById('deleteEventBtn');
    const closeEventBtn = document.getElementById('closeEventBtn');
    const newEventBtn = document.getElementById('newEventBtn');

    let googleTokenClient = null;
    let currentView = 'month';
    let cursor = new Date(); // current anchor date
    let calendars = []; // [{id, summary, backgroundColor, primary}]
    let events = []; // currently loaded events
    let currentEvent = null; // editing
    let visibleCalendars = new Set();
    let hasLoadedCalendars = false;

    function setStatus(t){ statusEl.textContent = t; }
    function setAuthLocked(on){
      document.body.classList.toggle('auth-locked', !!on);
    }

    // ====== HEARTBEAT ORIS (pour ATMOS) ======
    (function startOrisHeartbeat(){
      let bc = null;
      try { bc = new BroadcastChannel('ORIS_HEARTBEAT'); } catch(_) {}
      function beat(){
        try{ localStorage.setItem(ORIS_BEAT_KEY, Date.now().toString()); }catch{}
        try{ bc && bc.postMessage('ping'); }catch{}
      }
      // ping immédiat au chargement + intervalle + au retour en visibilité
      beat();
      setInterval(beat, ORIS_BEAT_INTERVAL);
      document.addEventListener('visibilitychange', ()=>{ if(!document.hidden) beat(); });
    })();

    // ====== DATE UTILS (Europe/Paris) ======
    function startOfDay(d){ const x = new Date(d); x.setHours(0,0,0,0); return x; }
    function endOfDay(d){ const x = new Date(d); x.setHours(23,59,59,999); return x; }
    function addDays(d,n){ const x = new Date(d); x.setDate(x.getDate()+n); return x; }
    function addMonths(d,n){ const x = new Date(d); x.setMonth(x.getMonth()+n); return x; }
    function startOfWeek(d){ const x = new Date(d); const day=(x.getDay()+6)%7; x.setDate(x.getDate()-day); x.setHours(0,0,0,0); return x; } // Monday
    function endOfWeek(d){ const s = startOfWeek(d); return addDays(s,6); }
    function startOfMonth(d){ return new Date(d.getFullYear(), d.getMonth(), 1); }
    function endOfMonth(d){ return new Date(d.getFullYear(), d.getMonth()+1, 0); }
    function fmtDate(d,opts){ return d.toLocaleString('fr-FR',opts||{ day:'2-digit', month:'2-digit', year:'numeric', hour:'2-digit', minute:'2-digit' }); }
    function toDate(value){
      if(!value) return null;
      const d = new Date(value);
      return Number.isNaN(d.valueOf()) ? null : d;
    }

    // ====== AUTH ======
    async function tryGoogleFromAtmos(){
      try{
        const { data } = await supabase.auth.getSession();
        const session = data?.session;
        if(!session) return false;
        const provider = session.user?.app_metadata?.provider;
        const accessToken = session.provider_token;
        if(provider === 'google' && accessToken){
          await waitForGapiReady();
          if(!window.__gapiReady){ return false; }
          gapi.client.setToken({ access_token: accessToken });
          logoutBtn.disabled = false;
          setStatus('Connecté à Google via ATMOS. Chargement des calendriers…');
          await bootCalendar();
          return true;
        }
        return false;
      }catch{ return false; }
    }

    async function ensureGsiLoaded(){
      if (window.google && google.accounts) return;
      await new Promise((resolve, reject)=>{
        const s = document.createElement('script');
        s.src = "https://accounts.google.com/gsi/client";
        s.async = true; s.defer = true;
        s.onload = resolve; s.onerror = reject;
        document.head.appendChild(s);
      });
    }

    async function loginGoogle(){
      if(document.body.classList.contains('auth-locked')){
        setStatus('Connexion à ATMOS requise.');
        return;
      }
      await ensureGsiLoaded();
      await waitForGapiReady();
      if(!window.__gapiReady){ setStatus('Google API non prête.'); return; }

      if(!googleTokenClient){
        googleTokenClient = google.accounts.oauth2.initTokenClient({
          client_id: GOOGLE_CLIENT_ID,
          scope: CAL_SCOPES,
          callback: async (resp)=>{
            if(resp && resp.access_token){
              gapi.client.setToken({ access_token: resp.access_token });
              logoutBtn.disabled = false;
              setStatus('Authentifié. Récupération des calendriers…');
              try{
                await bootCalendar();
              }catch(err){
                console.error('[ORIS] bootCalendar after login failed:', err);
              }
            }else{
              setStatus('Échec authentification Google.');
            }
          }
        });
      }
      googleTokenClient.requestAccessToken({ prompt:'' });
    }

    function logoutGoogle(){
      try{
        const tok = gapi.client.getToken();
        if(tok && tok.access_token){ google.accounts.oauth2.revoke(tok.access_token, ()=>{}); }
      }catch{}
      gapi.client.setToken('');
      if(refreshTimer){ clearInterval(refreshTimer); refreshTimer=null; }
      calendars=[]; events=[]; visibleCalendars = new Set(); hasLoadedCalendars = false; render();
      logoutBtn.disabled = true;
      setStatus('Déconnecté.');
    }

    // ====== CALENDAR API ======
    async function bootCalendar(){
      try{
        await loadCalendars();
        await loadEvents();
        autoRefresh();
        setStatus('Calendriers synchronisés.');
      }catch(err){
        console.error('[ORIS] bootCalendar error:', err);
        throw err;
      }
    }

    async function loadCalendars(){
      const res = await gapi.client.calendar.calendarList.list({ showHidden:false, minAccessRole:'reader' });
      calendars = (res.result.items||[]).map(c=>({
        id:c.id, summary:c.summary, backgroundColor: c.backgroundColor || '#0ea5e9', primary: !!c.primary
      }));
      // UI select
      calendarSelect.innerHTML = `<option value="">Tous les calendriers</option>` +
        calendars.map(c=>`<option value="${c.id}">${c.summary}${c.primary?' (principal)':''}</option>`).join('');
      // modal select
      fCalendar.innerHTML = calendars.map(c=>`<option value="${c.id}">${c.summary}${c.primary?' (principal)':''}</option>`).join('');
      // list with toggles
      const previousSelection = hasLoadedCalendars ? new Set(visibleCalendars) : null;
      visibleCalendars = new Set();
      calListEl.innerHTML = '';
      if(!calendars.length){
        calListEl.innerHTML = '<div class="status">Aucun calendrier disponible.</div>';
      }else{
        calendars.forEach(c=>{
          const item = document.createElement('label');
          item.className = 'cal-item';
          item.dataset.calendarId = c.id;

          const toggle = document.createElement('input');
          toggle.type = 'checkbox';
          const shouldCheck = previousSelection ? previousSelection.has(c.id) : true;
          toggle.checked = shouldCheck;
          toggle.setAttribute('aria-label', `Afficher le calendrier ${c.summary}`);

          const dot = document.createElement('span');
          dot.className = 'dot';
          dot.style.background = c.backgroundColor;

          const text = document.createElement('div');
          const labelText = document.createElement('strong');
          labelText.textContent = c.summary;
          text.appendChild(labelText);
          if(c.primary){
            const small = document.createElement('small');
            small.textContent = ' (principal)';
            text.appendChild(small);
          }

          if(shouldCheck){
            visibleCalendars.add(c.id);
          }else{
            item.classList.add('cal-hidden');
          }

          toggle.addEventListener('change', ()=>{
            if(toggle.checked){
              visibleCalendars.add(c.id);
              item.classList.remove('cal-hidden');
            }else{
              visibleCalendars.delete(c.id);
              item.classList.add('cal-hidden');
            }
            render();
          });

          item.appendChild(toggle);
          item.appendChild(dot);
          item.appendChild(text);
          calListEl.appendChild(item);
        });
      }
      hasLoadedCalendars = true;
      render();
    }

    function currentRange(){
      let start, end, label;
      if(currentView==='month'){
        start = startOfWeek(startOfMonth(cursor)); end = endOfWeek(endOfMonth(cursor));
        label = cursor.toLocaleDateString('fr-FR',{ month:'long', year:'numeric' });
      }else if(currentView==='week'){
        start = startOfWeek(cursor); end = endOfWeek(cursor);
        const a = start.toLocaleDateString('fr-FR',{ day:'2-digit', month:'short' });
        const b = end.toLocaleDateString('fr-FR',{ day:'2-digit', month:'short', year:'numeric' });
        label = `Semaine ${a} – ${b}`;
      }else{
        start = startOfDay(cursor); end = endOfDay(cursor);
        label = cursor.toLocaleDateString('fr-FR',{ weekday:'long', day:'numeric', month:'long', year:'numeric' });
      }
      return { start, end, label };
    }

    async function loadEvents(){
      try{
        const { start, end, label } = currentRange();
        periodLabel.textContent = label;

        const params = {
          calendarId: 'primary', // we’ll loop later
          timeMin: start.toISOString(),
          timeMax: end.toISOString(),
          singleEvents: true,
          orderBy: 'startTime',
          maxResults: 2500
        };

        const sel = calendarSelect.value;
        let evts = [];

        const calendarsToQuery = sel ? calendars.filter(c=>c.id===sel) : calendars;
        for(const cal of calendarsToQuery){
          const r = await gapi.client.calendar.events.list({ ...params, calendarId: cal.id });
          const items = (r.result.items||[]).map(e=>{
          const startRaw = e.start?.dateTime || e.start?.date;
          const endRaw = e.end?.dateTime || e.end?.date || startRaw;
          const allDay = !!e.start?.date && !e.start?.dateTime;
          const startDate = toDate(startRaw) || new Date();
          const endDateRaw = toDate(endRaw) || startDate;
          const displayEnd = allDay
            ? (endDateRaw > startDate ? addDays(endDateRaw, -1) : startDate)
            : endDateRaw;
          return {
            id:e.id,
            calId:cal.id,
            calName:cal.summary,
            color: cal.backgroundColor,
            summary:e.summary||'(Sans titre)',
            location:e.location||'',
            description:e.description||'',
            startRaw,
            endRaw,
            startDate,
            endDate: displayEnd,
            allDay,
            hangoutLink: e.hangoutLink || '',
            recurring: !!e.recurrence?.length,
            raw:e
          };
        });
          evts.push(...items);
        }
        events = evts;
        render();
      }catch(err){
        console.error('[ORIS] loadEvents error:', err);
        setStatus('Erreur lors du chargement des événements.');
        throw err;
      }
    }

    async function saveEvent(data){
      // data: {id?, calId, summary, description, location, startISO?, endISO?, startDate?, endDate?, allDay, meet:'create'|''}
      const resource = composeEventResource(data);
      if(data.id){
        const res = await gapi.client.calendar.events.patch({
          calendarId: data.calId,
          eventId: data.id,
          resource
        });
        return res.result;
      }
      const params = {
        calendarId: data.calId,
        resource
      };
      if(data.meet === 'create'){
        params.conferenceDataVersion = 1;
      }
      const res = await gapi.client.calendar.events.insert(params);
      return res.result;
    }

    function composeEventResource(d){
      const body = {
        summary: d.summary || '(Sans titre)',
        description: d.description || '',
        location: d.location || ''
      };
      if(d.allDay){
        body.start = { date: d.startDate };
        body.end = { date: d.endDate };
      }else{
        body.start = { dateTime: d.startISO };
        body.end = { dateTime: d.endISO };
      }
      if(d.meet==='create'){
        body.conferenceData = {
          createRequest: {
            requestId: 'meet-'+Math.random().toString(36).slice(2),
            conferenceSolutionKey: { type:'hangoutsMeet' }
          }
        };
      }
      return body;
    }

    async function deleteEvent(calId, id){
      await gapi.client.calendar.events.delete({ calendarId: calId, eventId: id });
    }

    // ====== RENDER ======
    function render(){
      const { start, end } = currentRange();
      const activeEvents = hasLoadedCalendars ? events.filter(ev=>visibleCalendars.has(ev.calId)) : events.slice();
      if(hasLoadedCalendars && calendars.length === 0){
        gridEl.className = 'grid day';
        gridEl.innerHTML = '';
        const message = document.createElement('div');
        message.className = 'cell';
        message.style.gridColumn = '1 / -1';
        message.style.minHeight = '200px';
        message.style.display = 'flex';
        message.style.alignItems = 'center';
        message.style.justifyContent = 'center';
        message.innerHTML = '<div class="status">Aucun calendrier disponible.</div>';
        gridEl.appendChild(message);
        return;
      }
      if(hasLoadedCalendars && visibleCalendars.size === 0){
        gridEl.className = 'grid day';
        gridEl.innerHTML = '';
        const message = document.createElement('div');
        message.className = 'cell';
        message.style.gridColumn = '1 / -1';
        message.style.minHeight = '200px';
        message.style.display = 'flex';
        message.style.alignItems = 'center';
        message.style.justifyContent = 'center';
        message.innerHTML = '<div class="status">Sélectionnez un calendrier à afficher.</div>';
        gridEl.appendChild(message);
        return;
      }

      gridEl.className = 'grid ' + currentView;
      gridEl.innerHTML = '';

      if(currentView==='month'){
        // headers
        ['Lun','Mar','Mer','Jeu','Ven','Sam','Dim'].forEach(d=>{
          const h = document.createElement('div'); h.className='cell head'; h.textContent = d; gridEl.appendChild(h);
        });
        const first = start; const days = Math.round((end-first)/(86400000))+1;
        for(let i=0;i<days;i++){
          const day = addDays(first,i);
          const cell = document.createElement('div'); cell.className='cell'; cell.dataset.date = day.toISOString();
          const head = document.createElement('div'); head.style.display='flex'; head.style.justifyContent='space-between'; head.style.alignItems='center';
          head.innerHTML = `<strong>${day.getDate()}</strong>`;
          const plus = document.createElement('button'); plus.className='btn small'; plus.textContent='+'; plus.title='Nouvel événement';
          plus.onclick = (e)=>{ e.stopPropagation(); openEventModal({ start: day, end: addDays(day,1), allDay:true }); };
          head.appendChild(plus);
          cell.appendChild(head);

          const list = document.createElement('div');
          activeEvents.filter(ev=>{
            const s = ev.startDate;
            const e = ev.endDate || ev.startDate;
            const d0 = startOfDay(day);
            return s <= endOfDay(day) && e >= d0; // overlap day
          }).slice(0,5).forEach(ev=>{
            const div = document.createElement('div'); div.className='event';
            const when = ev.allDay ? 'Journée' : `${ev.startDate.toLocaleTimeString('fr-FR',{hour:'2-digit',minute:'2-digit'})}`;
            div.innerHTML = `<div style="display:flex; gap:6px; align-items:center"><span class="dot" style="background:${ev.color}"></span><strong>${escapeHtml(ev.summary)}</strong></div><div class="when">${when} — ${escapeHtml(ev.calName)}</div>`;
            div.onclick = ()=> openEventModal({ existing: ev });
            list.appendChild(div);
          });
          cell.appendChild(list);
          gridEl.appendChild(cell);
        }
      }

      if(currentView==='week'){
        // header row
        const head0 = document.createElement('div'); head0.className='cell head'; head0.textContent='Heure'; gridEl.appendChild(head0);
        for(let i=0;i<7;i++){
          const d = addDays(startOfWeek(cursor), i);
          const h = document.createElement('div'); h.className='cell head'; h.innerHTML = d.toLocaleDateString('fr-FR',{weekday:'short', day:'2-digit', month:'2-digit'});
          gridEl.appendChild(h);
        }
        // body: simple lists by day
        for(let row=0; row<12; row++){
          const hourLabel = document.createElement('div'); hourLabel.className='cell head'; hourLabel.textContent = (row*2).toString().padStart(2,'0')+':00';
          gridEl.appendChild(hourLabel);
          for(let i=0;i<7;i++){
            const d = addDays(startOfWeek(cursor), i);
            const cell = document.createElement('div'); cell.className='cell'; cell.dataset.date = d.toISOString();
            const plus = document.createElement('button'); plus.className='btn small'; plus.textContent='+'; plus.title='Nouvel événement';
            plus.onclick = (e)=>{ e.stopPropagation(); openEventModal({ start: new Date(d.getFullYear(), d.getMonth(), d.getDate(), row*2), end: new Date(d.getFullYear(), d.getMonth(), d.getDate(), row*2+1) }); };
            cell.appendChild(plus);
            activeEvents.filter(ev=>{
              const s = ev.startDate; const e = ev.endDate || ev.startDate;
              return s <= endOfDay(d) && e >= startOfDay(d);
            }).slice(0,4).forEach(ev=>{
              const div=document.createElement('div'); div.className='event';
              const when = ev.allDay ? 'Journée' : `${ev.startDate.toLocaleTimeString('fr-FR',{hour:'2-digit',minute:'2-digit'})}`;
              div.innerHTML = `<div style="display:flex;gap:6px;align-items:center"><span class="dot" style="background:${ev.color}"></span><strong>${escapeHtml(ev.summary)}</strong></div><div class="when">${when} — ${escapeHtml(ev.calName)}</div>`;
              div.onclick = ()=> openEventModal({ existing: ev });
              cell.appendChild(div);
            });
            gridEl.appendChild(cell);
          }
        }
      }

      if(currentView==='day'){
        const d = cursor;
        const head = document.createElement('div'); head.className='cell head'; head.textContent = d.toLocaleDateString('fr-FR',{weekday:'long', day:'numeric', month:'long', year:'numeric'});
        gridEl.appendChild(head);
        const cell = document.createElement('div'); cell.className='cell';
        const plus = document.createElement('button'); plus.className='btn small'; plus.textContent='+'; plus.title='Nouvel événement';
        plus.onclick = ()=> openEventModal({ start: d, end: addDays(d,0), allDay:false });
        cell.appendChild(plus);
        activeEvents.filter(ev=>{
          const s = ev.startDate; const e = ev.endDate || ev.startDate;
          return s <= endOfDay(d) && e >= startOfDay(d);
        }).forEach(ev=>{
          const div=document.createElement('div'); div.className='event';
          const endDisplay = ev.endDate || ev.startDate;
          const when = ev.allDay ? 'Journée' : `${ev.startDate.toLocaleTimeString('fr-FR',{hour:'2-digit',minute:'2-digit'})} → ${endDisplay.toLocaleTimeString('fr-FR',{hour:'2-digit',minute:'2-digit'})}`;
          div.innerHTML = `<div style="display:flex;gap:6px;align-items:center"><span class="dot" style="background:${ev.color}"></span><strong>${escapeHtml(ev.summary)}</strong></div><div class="when">${when} — ${escapeHtml(ev.calName)}</div>${ev.location?`<div class="when">📍 ${escapeHtml(ev.location)}</div>`:''}`;
          div.onclick = ()=> openEventModal({ existing: ev });
          cell.appendChild(div);
        });
        gridEl.appendChild(cell);
      }
    }

    function escapeHtml(s){ return String(s||'').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

    // ====== EVENT MODAL ======
    function openEventModal({ existing=null, start=null, end=null, allDay=false }){
      currentEvent = existing;
      evtTitle.textContent = existing ? 'Modifier l’événement' : 'Nouvel événement';
      deleteEventBtn.style.display = existing ? '' : 'none';

      // calendars select
      fCalendar.innerHTML = calendars.map(c=>`<option value="${c.id}">${c.summary}${c.primary?' (principal)':''}</option>`).join('');

      if(existing){
        fTitle.value = existing.summary || '';
        fCalendar.value = existing.calId;
        if(existing.allDay){
          const s = toDate(`${existing.startRaw}T00:00`) || new Date();
          const exclusiveEnd = toDate(`${(existing.endRaw || existing.startRaw)}T00:00`);
          const inclusiveEnd = exclusiveEnd ? addDays(exclusiveEnd, -1) : s;
          fStart.value = toLocalInputValue(s, false);
          fEnd.value = toLocalInputValue(inclusiveEnd, false);
        }else{
          const s = toDate(existing.startRaw) || new Date();
          const e = toDate(existing.endRaw || existing.startRaw) || s;
          fStart.value = toLocalInputValue(s, true);
          fEnd.value = toLocalInputValue(e, true);
        }
        fLocation.value = existing.location || '';
        fDesc.value = existing.description || '';
        fMeet.value = existing.raw.conferenceData?.entryPoints?.length ? '' : '';
      }else{
        fTitle.value = '';
        fCalendar.value = (calendars.find(c=>c.primary)?.id) || calendars[0]?.id || '';
        const s = start || new Date();
        fStart.value = toLocalInputValue(s, !allDay);
        if(allDay){
          const endCandidate = end ? addDays(end, -1) : s;
          fEnd.value = toLocalInputValue(endCandidate, false);
        }else{
          const endCandidate = end || addMinutes(s,60);
          fEnd.value = toLocalInputValue(endCandidate, true);
        }
        fLocation.value = '';
        fDesc.value = '';
        fMeet.value = '';
      }

      eventModal.style.display = 'flex';
      eventModal.setAttribute('aria-hidden','false');
    }
    function closeEventModal(){
      eventModal.style.display='none';
      eventModal.setAttribute('aria-hidden','true');
      currentEvent = null;
    }
    function addMinutes(d,m){ const x=new Date(d); x.setMinutes(x.getMinutes()+m); return x; }
    function toLocalInputValue(d, withTime){
      const pad = (n)=> String(n).padStart(2,'0');
      const yyyy = d.getFullYear(), mm = pad(d.getMonth()+1), dd = pad(d.getDate());
      if(!withTime) return `${yyyy}-${mm}-${dd}T00:00`;
      const hh = pad(d.getHours()), mi = pad(d.getMinutes());
      return `${yyyy}-${mm}-${dd}T${hh}:${mi}`;
    }
    function toDateOnlyString(d){
      const pad = (n)=> String(n).padStart(2,'0');
      return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`;
    }

    saveEventBtn.onclick = async ()=>{
      try{
        const startValue = fStart.value;
        const endValue = fEnd.value;
        if(!startValue || !endValue){ alert('Veuillez renseigner des dates de début et de fin.'); return; }
        const allDay = startValue.slice(11) === '00:00' && endValue.slice(11) === '00:00';
        const base = {
          id: currentEvent?.id || null,
          calId: fCalendar.value,
          summary: fTitle.value.trim(),
          description: fDesc.value,
          location: fLocation.value,
          allDay,
          meet: fMeet.value
        };
        if(allDay){
          const startDateStr = startValue.slice(0,10);
          const endDateStr = endValue.slice(0,10);
          if(!startDateStr || !endDateStr){ alert('Format de date invalide.'); return; }
          const startDay = toDate(`${startDateStr}T00:00`);
          const endDay = toDate(`${endDateStr}T00:00`);
          if(!startDay || !endDay){ alert('Format de date invalide.'); return; }
          if(endDay < startDay){ alert('La date de fin ne peut pas être antérieure à la date de début.'); return; }
          base.startDate = toDateOnlyString(startDay);
          base.endDate = toDateOnlyString(addDays(endDay, 1));
        }else{
          const start = toDate(startValue);
          const end = toDate(endValue);
          if(!start || !end){ alert('Dates/heures invalides.'); return; }
          if(end <= start){ alert('La date de fin doit être postérieure à la date de début.'); return; }
          base.startISO = start.toISOString();
          base.endISO = end.toISOString();
        }
        await saveEvent(base);
        closeEventModal();
        setStatus('Événement enregistré.');
        await loadEvents();
      }catch(e){ console.error(e); alert('Échec enregistrement (permissions ?).'); }
    };
    deleteEventBtn.onclick = async ()=>{
      if(!currentEvent) return;
      if(!confirm('Supprimer cet événement ?')) return;
      try{
        await deleteEvent(currentEvent.calId, currentEvent.id);
        closeEventModal();
        setStatus('Événement supprimé.');
        await loadEvents();
      }catch(e){ console.error(e); alert('Échec suppression.'); }
    };
    closeEventBtn.onclick = closeEventModal;

    // ====== TASKS (SPHAIRA) ======
    const STORAGE_KEYS = ['sphaira:workspaceState:v1','workspaceState'];
    function loadWorkspaceFromStorage(){
      for(const key of STORAGE_KEYS){
        try{
          const raw = localStorage.getItem(key);
          if(raw){ const json=JSON.parse(raw); return { json, storageKey:key }; }
        }catch(e){}
      }
      return { json:null, storageKey:null };
    }
    function extractTasks(ws){
      if(!ws || !Array.isArray(ws.nodes)) return [];
      const nodes = Object.fromEntries(ws.nodes.map(n=>[n.id, {name:n.text||n.id, color:n.color||'#00EAFF'}]));
      const tasks=[];
      ws.nodes.forEach(n=>{
        (n.tasks||[]).forEach(t=>{
          tasks.push({
            id:t.id, title: t.title||'(Sans titre)', desc: t.desc||'',
            start: t.start||'', end: t.end||'',
            nodeName: nodes[n.id]?.name || n.id, color: nodes[n.id]?.color || '#00EAFF'
          });
        });
      });
      return tasks;
    }
    function renderTasks(){
      const { json } = loadWorkspaceFromStorage();
      const list = json ? extractTasks(json) : [];
      if(!list.length){ taskListEl.innerHTML = '<div class="status">Aucune tâche trouvée.</div>'; return; }
      taskListEl.innerHTML = '';
      list.sort((a,b)=> (a.start||'').localeCompare(b.start||'') || a.title.localeCompare(b.title))
        .forEach(t=>{
          const el = document.createElement('div');
          el.className='task';
          el.innerHTML = `<span class="dot" style="background:${t.color}"></span>
            <div>
              <div><strong>${escapeHtml(t.title)}</strong></div>
              ${t.start || t.end ? `<small>${t.start ? 'Du '+t.start : ''} ${t.end ? ' au '+t.end : ''}</small><br/>` : ''}
              ${t.nodeName ? `<small>Sur : ${escapeHtml(t.nodeName)}</small>`:''}
              ${t.desc ? `<div style="margin-top:6px">${escapeHtml(t.desc)}</div>`:''}
            </div>`;
          taskListEl.appendChild(el);
        });
    }
    toggleTasksBtn.onclick = ()=>{
      const hidden = tasksSection.style.display === 'none';
      tasksSection.style.display = hidden ? '' : 'none';
    }; // simple toggle
    window.addEventListener('storage', (e)=>{ if(STORAGE_KEYS.includes(e.key)) renderTasks(); });

    // ====== NAV + SEARCH ======
    prevBtn.onclick = async ()=>{ cursor = currentView==='month' ? addMonths(cursor, -1) : addDays(cursor, currentView==='week'?-7:-1); await loadEvents(); };
    nextBtn.onclick = async ()=>{ cursor = currentView==='month' ? addMonths(cursor, +1) : addDays(cursor, currentView==='week'?+7:+1); await loadEvents(); };
    todayBtn.onclick = async ()=>{ cursor = new Date(); await loadEvents(); };
    viewBtns.forEach(b=> b.onclick = async ()=>{
      viewBtns.forEach(x=>x.classList.remove('active'));
      b.classList.add('active'); currentView = b.dataset.view; await loadEvents();
    });
    searchBtn.onclick = ()=> {
      const q = searchInput.value.trim().toLowerCase();
      if(!q){
        render();
        return;
      }
      const filtered = events.filter(e=>{
        if(hasLoadedCalendars && !visibleCalendars.has(e.calId)) return false;
        const summary = (e.summary||'').toLowerCase();
        const location = (e.location||'').toLowerCase();
        const description = (e.description||'').toLowerCase();
        return summary.includes(q) || location.includes(q) || description.includes(q);
      });
      const keep = events; events = filtered; render(); events = keep; // render filtered once
    };
    calendarSelect.onchange = async ()=>{
      const sel = calendarSelect.value;
      if(sel && hasLoadedCalendars && !visibleCalendars.has(sel)){
        visibleCalendars.add(sel);
        const item = Array.from(calListEl.querySelectorAll('.cal-item')).find(el=>el.dataset.calendarId === sel);
        if(item){
          const toggle = item.querySelector('input[type="checkbox"]');
          if(toggle) toggle.checked = true;
          item.classList.remove('cal-hidden');
        }
      }
      await loadEvents();
    };
    refreshBtn.onclick = loadEvents;

    // ====== AUTO REFRESH ======
    let refreshTimer=null;
    function autoRefresh(){
      if(refreshTimer) clearInterval(refreshTimer);
      refreshTimer = setInterval(()=>{ loadEvents().catch(()=>{}); }, 60_000); // 60s
    }

    // ====== BOOT ======
    function bindAuth(){
      googleBtn.onclick = loginGoogle;
      logoutBtn.onclick = logoutGoogle;
    }
    bindAuth();

    async function checkAuth(){
      const { data } = await supabase.auth.getSession();
      setAuthLocked(!data?.session);
      if(data?.session){
        const ok = await tryGoogleFromAtmos();
        if(!ok){ setStatus('Session ATMOS active : cliquez « Connecter Google ».'); }
      }
    }
    supabase.auth.onAuthStateChange(async (_evt, session) => {
      setAuthLocked(!session);
      if(session){ await tryGoogleFromAtmos(); }
    });

    // initial
    checkAuth();
    renderTasks();
    if (location.protocol === "file:") {
      console.warn("⚠️ Ouvre via HTTPS (ou un serveur local) pour l’auth Google.");
    }
  </script>
</body>
</html>
