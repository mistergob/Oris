<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <title>ORIS</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Polices ATMOS -->
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700;900&family=Outfit:wght@300;400;600&display=swap" rel="stylesheet"/>

  <style>
    :root{
      --primary:#00eaff; --accent:#8a2be2; --text:#e6f7ff; --muted:#9fb3c8;
      --space-img:url("https://images.unsplash.com/photo-1444703686981-a3abbc4d4fe3?q=80&w=1920&auto=format&fit=crop");
      --bg-a:#05060d; --bg-b:#0b1430; --bg-c:#00182a;
      --glow: drop-shadow(0 0 8px rgba(0,234,255,.55)) drop-shadow(0 0 18px rgba(138,43,226,.35));
      --ring: 0 0 0 3px rgba(0,234,255,.35), 0 0 24px rgba(0,234,255,.25);
      --grid:rgba(255,255,255,.12);
      --glass: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      --card: rgba(8,12,28,.55);
      --ok:#16a34a; --warn:#f59e0b; --danger:#ef4444;
      --sidebar-w: 340px;
      --toolbar-h: 64px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;color:var(--text);
      font-family: Outfit, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background:
        radial-gradient(1200px 800px at 75% 10%, rgba(138,43,226,.18), transparent 60%),
        radial-gradient(900px 700px at 15% 85%, rgba(0,234,255,.12), transparent 55%),
        radial-gradient(700px 500px at 80% 80%, rgba(0,40,80,.35), transparent 60%),
        linear-gradient(120deg, var(--bg-a), var(--bg-b) 40%, var(--bg-c));
      overflow:hidden;
    }
    body::before{
      content:""; position:fixed; inset:0; pointer-events:none; mix-blend-mode:screen; opacity:.15; z-index:-1;
      background:
        var(--space-img) center/cover no-repeat,
        radial-gradient(1px 1px at 10% 20%, #fff 40%, transparent 41%),
        radial-gradient(1px 1px at 30% 80%, #fff 40%, transparent 41%),
        radial-gradient(1px 1px at 70% 30%, #fff 40%, transparent 41%),
        radial-gradient(1px 1px at 90% 60%, #fff 40%, transparent 41%);
      animation: twinkle 14s linear infinite;
    }
    @keyframes twinkle{0%,100%{opacity:.12}50%{opacity:.22}}
    body::after{content:""; position:fixed; inset:-10%; pointer-events:none; z-index:-1; filter:blur(24px);
      background: radial-gradient(600px 320px at 50% 25%, rgba(0,234,255,.18), transparent 60%),
                  radial-gradient(900px 420px at 50% 70%, rgba(138,43,226,.18), transparent 65%);
      animation: float 18s ease-in-out infinite alternate;
    }
    @keyframes float{from{transform:translateY(-1.5%)}to{transform:translateY(1.5%)}}

    .shell{display:grid; grid-template-columns: 1fr var(--sidebar-w); gap:12px; height:100vh; padding:12px; max-width:1600px; margin:0 auto}
    .main{display:flex; flex-direction:column; min-width:0}
    .right{display:flex; flex-direction:column; min-width:0}

    .topbar{
      height:var(--toolbar-h);
      display:flex; align-items:center; gap:10px;
      background:var(--glass); border:1px solid var(--grid); border-radius:16px; padding:10px 12px;
      box-shadow:0 12px 40px rgba(0,0,0,.35); backdrop-filter: blur(8px);
    }
    .topbar h1{margin:0 8px 0 4px; font:700 16px/1 Orbitron, sans-serif; letter-spacing:.06em}
    .spacer{flex:1}
    .btn{
      appearance:none; cursor:pointer; border:1px solid transparent; border-radius:12px; padding:10px 12px; color:var(--text);
      background: linear-gradient(#0c1327,#0b1120) padding-box,
                  conic-gradient(from 180deg, rgba(0,234,255,.8), rgba(138,43,226,.8), rgba(0,234,255,.8)) border-box;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.04), 0 8px 24px rgba(0,0,0,.45);
      transition: transform .2s ease, filter .2s ease, box-shadow .2s ease; font-weight:600; letter-spacing:.02em;
    }
    .btn:hover{ transform: translateY(-2px); filter: var(--glow); }
    .btn:focus-visible{ outline:none; box-shadow: var(--ring); }
    .btn.small{padding:6px 10px; border-radius:10px; font-size:12px}
    .btn.ghost{ background:transparent; border:1px solid var(--grid) }

    .input,.select{
      height:36px; border:1px solid var(--grid); border-radius:10px; background:rgba(8,12,28,.6); color:var(--text); padding:0 10px; outline:none;
    }
    .status{font-size:12px;color:var(--muted)}
    .bar{display:flex; align-items:center; gap:8px}

    /* Agenda container */
    .calendar-wrap{
      flex:1; min-height:0; margin-top:12px;
      background:var(--glass); border:1px solid var(--grid); border-radius:16px; padding:8px;
      box-shadow:0 12px 40px rgba(0,0,0,.35); backdrop-filter: blur(8px);
      display:flex; flex-direction:column; overflow:hidden;
    }
    .calendar-toolbar{display:flex; align-items:center; gap:8px; padding:6px 8px}
    .calendar-canvas{flex:1; min-height:0; border:1px solid var(--grid); border-radius:12px; background:var(--card); overflow:auto; position:relative}

    /* Simple month/week/day header */
    .seg{display:inline-flex; border:1px solid var(--grid); border-radius:10px; overflow:hidden}
    .seg button{border:0;background:transparent;color:var(--text);padding:6px 10px;cursor:pointer}
    .seg button.active{background:rgba(255,255,255,.08)}

    /* Event list in day/week/month grid (homemade) */
    .grid{display:grid; gap:6px; padding:8px}
    .grid.month{grid-template-columns:repeat(7,1fr)}
    .grid.week{grid-template-columns: 100px repeat(7,1fr)}
    .grid.day{grid-template-columns: 1fr}
    .cell{border:1px solid var(--grid); border-radius:10px; padding:8px; min-height:100px; background:rgba(255,255,255,.03)}
    .cell.head{min-height:auto; text-align:center; font-size:12px; color:var(--muted)}
    .event{margin:4px 0; padding:6px 8px; border:1px solid var(--grid); border-radius:8px; background:rgba(0,0,0,.25); font-size:12px; cursor:pointer}
    .event.draggable{cursor:grab}
    .event.draggable:active{cursor:grabbing}
    .event.dragging{opacity:.6; filter:var(--glow)}
    .event:hover{filter:var(--glow)}
    .cell.drag-over{outline:1px dashed rgba(0,234,255,.6); background:rgba(0,234,255,.08)}
    .when{opacity:.8; font-size:11px}

    /* Right panel: calendars + tasks */
    .panel{
      height:100%;
      display:grid; grid-template-rows: var(--toolbar-h) 1fr;
    }
    .panel-head{
      display:flex; align-items:center; gap:8px; background:var(--glass); border:1px solid var(--grid); border-radius:16px; padding:10px 12px;
      box-shadow:0 12px 40px rgba(0,0,0,.35); backdrop-filter: blur(8px);
    }
    .panel-body{
      margin-top:12px; background:var(--glass); border:1px solid var(--grid); border-radius:16px; padding:10px; overflow:auto;
      box-shadow:0 12px 40px rgba(0,0,0,.35); backdrop-filter: blur(8px);
    }
    .section{border:1px solid var(--grid); border-radius:12px; padding:10px; margin-bottom:10px; background:rgba(255,255,255,.03)}
    .section h3{margin:0 0 8px; font-family:Orbitron,sans-serif; letter-spacing:.06em; font-size:14px}
    .cal-item{display:flex; align-items:center; gap:8px; padding:6px 8px; border:1px solid var(--grid); border-radius:10px; margin:6px 0; background:rgba(0,0,0,.25); cursor:pointer}
    .cal-item input[type="checkbox"]{width:16px;height:16px;accent-color:var(--primary);cursor:pointer;flex:0 0 auto}
    .cal-item.cal-hidden{opacity:.45}
    .dot{width:10px;height:10px;border-radius:9999px;border:1px solid var(--grid);flex:0 0 auto}
    .task{display:flex; align-items:flex-start; gap:8px; border:1px solid var(--grid); border-radius:10px; padding:8px; margin:6px 0; background:rgba(0,0,0,.25)}
    .task small{color:var(--muted)}

    /* Modal event editor */
    .modal{position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(3,6,16,.55); z-index:50; backdrop-filter: blur(2px);}
    .modal .card{width:min(720px,calc(100vw - 24px)); background:var(--glass); border:1px solid var(--grid); border-radius:16px; padding:12px; box-shadow:0 20px 40px rgba(0,0,0,.35)}
    .row{display:flex; gap:8px}
    .row > *{flex:1}
    label{font-size:12px; color:var(--muted)}
    input, textarea, select{width:100%; background:rgba(0,0,0,.25); color:var(--text); border:1px solid var(--grid); border-radius:10px; padding:8px}
    textarea{min-height:96px; resize:vertical}

    /* AUTH LOCK */
    .auth-block{
      position:fixed; inset:0; display:none; align-items:center; justify-content:center;
      background:rgba(3,6,16,.65); backdrop-filter:blur(3px); z-index:9999;
    }
    .auth-card{
      width:min(520px,calc(100vw - 32px)); padding:16px; border-radius:16px;
      border:1px solid rgba(255,255,255,.06);
      background:var(--glass);
      box-shadow:0 20px 40px rgba(0,0,0,.45); color:var(--text);
    }
    .auth-card h3{ margin:0 0 8px; font-family:Orbitron,sans-serif; letter-spacing:.06em }

    body.auth-locked .auth-block{ display:flex; }
    body.auth-locked .shell{ pointer-events:none; filter:grayscale(1) opacity(.35) }
    @media (prefers-reduced-motion: reduce){ *{animation:none!important; transition:none!important} }
  </style>

  <!-- Google API -->
  <script>
    window.__gapiReady = false;
    window.__gapiError = null;
    async function onGapiLoad(){
      if (!window.gapi) { window.__gapiError = new Error('gapi non charg√©'); return; }
      try{
        await new Promise(res => gapi.load('client', res));
        await gapi.client.init({ discoveryDocs: [
          'https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest'
        ]});
        window.__gapiReady = true;
        console.log('[ORIS] GAPI pr√™t (Calendar)');
      }catch(err){
        window.__gapiError = err;
        console.error('[ORIS] Erreur init GAPI:', err);
      }
    }
    function waitForGapiReady(timeoutMs=7000){
      return new Promise(resolve=>{
        if(window.__gapiReady) return resolve();
        const t0 = Date.now();
        const id = setInterval(()=>{
          if(window.__gapiReady || window.__gapiError || Date.now()-t0>timeoutMs){
            clearInterval(id); resolve();
          }
        }, 100);
      });
    }
  </script>
  <script src="https://apis.google.com/js/api.js?onload=onGapiLoad" async defer></script>
  <script src="https://accounts.google.com/gsi/client" async defer></script>
</head>

<body class="auth-locked">
  <div class="shell">
    <div class="main">
      <!-- TOPBAR -->
      <div class="topbar">
        <h1>Agenda ‚Äî <span class="appname">ORIS</span></h1>
        <button class="btn small" id="googleBtn">Connecter Google</button>
        <button class="btn small ghost" id="logoutBtn" disabled>D√©connexion</button>
        <div class="spacer"></div>
        <div class="bar">
          <button class="btn small" id="prevBtn">‚óÄ</button>
          <button class="btn small" id="todayBtn">Aujourd‚Äôhui</button>
          <button class="btn small" id="nextBtn">‚ñ∂</button>

          <div class="seg" role="tablist" aria-label="Vues">
            <button class="viewBtn active" data-view="month">Mois</button>
            <button class="viewBtn" data-view="week">Semaine</button>
            <button class="viewBtn" data-view="day">Jour</button>
          </div>

          <input id="searchInput" class="input" type="search" placeholder="Rechercher (titre, lieu‚Ä¶)" style="min-width:220px">
          <button id="searchBtn" class="btn small">Rechercher</button>
        </div>
      </div>

      <!-- AGENDA -->
      <div class="calendar-wrap">
        <div class="calendar-toolbar">
          <div class="bar">
            <select id="calendarSelect" class="select" title="Calendrier">
              <option value="">Tous les calendriers</option>
            </select>
            <button id="newEventBtn" class="btn small">+ Nouvel √©v√©nement</button>
            <span id="status" class="status">Connexion requise.</span>
          </div>
          <div class="spacer"></div>
          <div class="bar">
            <span class="status" id="periodLabel">‚Äî</span>
          </div>
        </div>
        <div id="canvas" class="calendar-canvas">
          <div id="grid" class="grid month"></div>
        </div>
      </div>
    </div>

    <!-- RIGHT PANEL: Calendriers + T√¢ches (SPHAIRA) -->
    <div class="right panel">
      <div class="panel-head">
        <strong style="font-family:Orbitron">ORIS ‚Äî Panneau</strong>
        <div class="spacer"></div>
        <button id="toggleTasks" class="btn small">T√¢ches</button>
        <button id="refreshBtn" class="btn small">Rafra√Æchir</button>
      </div>
      <div class="panel-body" id="sideBody">
        <div class="section" id="calendarsSection">
          <h3>Calendriers</h3>
          <div id="calList"></div>
        </div>
        <div class="section" id="tasksSection">
          <h3>T√¢ches (SPHAIRA)</h3>
          <div id="taskList">‚Äî</div>
          <div style="margin-top:6px" class="status">Source : SPHAIRA (localStorage).</div>
        </div>
      </div>
    </div>
  </div>

  <!-- EVENT EDITOR MODAL -->
  <div id="eventModal" class="modal" aria-hidden="true" role="dialog" aria-label="√âdition √©v√©nement">
    <div class="card">
      <div style="display:flex; align-items:center; justify-content:space-between; gap:8px">
        <h3 id="evtTitle">Nouvel √©v√©nement</h3>
        <div class="bar">
          <button id="saveEventBtn" class="btn">Enregistrer</button>
          <button id="deleteEventBtn" class="btn ghost" style="display:none">Supprimer</button>
          <button id="closeEventBtn" class="btn">Fermer</button>
        </div>
      </div>
      <div class="row">
        <div>
          <label>Titre</label>
          <input id="fTitle" placeholder="Titre">
        </div>
        <div>
          <label>Calendrier</label>
          <select id="fCalendar"></select>
        </div>
      </div>
      <div class="row">
        <div>
          <label>D√©but</label>
          <input id="fStart" type="datetime-local">
        </div>
        <div>
          <label>Fin</label>
          <input id="fEnd" type="datetime-local">
        </div>
      </div>
      <div class="row">
        <div>
          <label>Lieu</label>
          <input id="fLocation" placeholder="Lieu">
        </div>
        <div>
          <label>Visio (Meet)</label>
          <select id="fMeet">
            <option value="">‚Äî</option>
            <option value="create">Cr√©er un lien Meet</option>
          </select>
        </div>
      </div>
      <div>
        <label>Description</label>
        <textarea id="fDesc" placeholder="D√©tails"></textarea>
      </div>
    </div>
  </div>

  <!-- AUTH OVERLAY (SSO ATMOS) -->
  <div id="authBlock" class="auth-block" aria-live="polite" role="alert">
    <div class="auth-card">
      <h3>Connexion n√©cessaire</h3>
      <p>Connectez-vous sur <strong>ATMOS</strong> pour utiliser ORIS.</p>
      <div class="actions" style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
        <a id="authGoAtmos" class="btn">Se connecter sur ATMOS</a>
      </div>
    </div>
  </div>

  <!-- APP LOGIC -->
  <script>
    'use strict';

    // ====== CONFIG ======
    const GOOGLE_CLIENT_ID = "514694919456-u0csh5so13bsb8u0cl5a7fl5lgmla4c4.apps.googleusercontent.com";
    const CAL_SCOPES = 'https://www.googleapis.com/auth/calendar';

    // Supabase (SSO)
    const PROJECT_REF = "jlfvbggzdkkwrmpsamvz";
    const SUPABASE_URL = `https://${PROJECT_REF}.supabase.co`;
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImpsZnZiZ2d6ZGtrd3JtcHNhbXZ6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTcyNjUyNjMsImV4cCI6MjA3Mjg0MTI2M30.kDbtNVQfHEVxRbA8jsAfLu7-6kDioTCG-nWVQ91gJIs";
    const ATMOS_URL = "https://mistergob.github.io/Atmos/";
    const STORAGE_KEY = `sb-${PROJECT_REF}-auth-token`;

    // Heartbeat keys / intervals
    const ORIS_BEAT_KEY = 'oris:beatAt';
    const ORIS_BEAT_INTERVAL = 10000; // 10s
  </script>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script>
    // ====== STATE ======
    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
      auth: { persistSession:true, autoRefreshToken:true, detectSessionInUrl:true, storage: window.localStorage, storageKey: STORAGE_KEY }
    });

    const authGo = document.getElementById('authGoAtmos');
    if (authGo) authGo.href = ATMOS_URL + "?r=" + encodeURIComponent(location.href);

    const statusEl = document.getElementById('status');
    const periodLabel = document.getElementById('periodLabel');
    const gridEl = document.getElementById('grid');
    const canvas = document.getElementById('canvas');

    const viewBtns = Array.from(document.querySelectorAll('.viewBtn'));
    const calendarSelect = document.getElementById('calendarSelect');

    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const todayBtn = document.getElementById('todayBtn');
    const searchInput = document.getElementById('searchInput');
    const searchBtn = document.getElementById('searchBtn');
    const refreshBtn = document.getElementById('refreshBtn');

    const googleBtn = document.getElementById('googleBtn');
    const logoutBtn = document.getElementById('logoutBtn');

    const calListEl = document.getElementById('calList');
    const tasksSection = document.getElementById('tasksSection');
    const taskListEl = document.getElementById('taskList');
    const toggleTasksBtn = document.getElementById('toggleTasks');

    const eventModal = document.getElementById('eventModal');
    const evtTitle = document.getElementById('evtTitle');
    const fTitle = document.getElementById('fTitle');
    const fCalendar = document.getElementById('fCalendar');
    const fStart = document.getElementById('fStart');
    const fEnd = document.getElementById('fEnd');
    const fLocation = document.getElementById('fLocation');
    const fDesc = document.getElementById('fDesc');
    const fMeet = document.getElementById('fMeet');
    const saveEventBtn = document.getElementById('saveEventBtn');
    const deleteEventBtn = document.getElementById('deleteEventBtn');
    const closeEventBtn = document.getElementById('closeEventBtn');
    const newEventBtn = document.getElementById('newEventBtn');

    let googleTokenClient = null;
    let currentView = 'month';
    let cursor = new Date(); // current anchor date
    let calendars = []; // [{id, summary, backgroundColor, primary}]
    let events = []; // currently loaded events
    let currentEvent = null; // editing
    let visibleCalendars = new Set();
    let hasLoadedCalendars = false;
    const SPHAIRA_CALENDAR_ID = 'sphaira-tasks';
    const SPHAIRA_CALENDAR = {
      id: SPHAIRA_CALENDAR_ID,
      summary: 'T√¢ches SPHAIRA',
      backgroundColor: '#00EAFF',
      isSphaira: true
    };
    let googleEvents = [];
    let sphairaEvents = [];
    let draggingEvent = null;
    let dragSourceEl = null;
    let isDraggingEvent = false;

    function setStatus(t){ statusEl.textContent = t; }
    function setAuthLocked(on){
      document.body.classList.toggle('auth-locked', !!on);
    }

    // ====== HEARTBEAT ORIS (pour ATMOS) ======
    (function startOrisHeartbeat(){
      let bc = null;
      try { bc = new BroadcastChannel('ORIS_HEARTBEAT'); } catch(_) {}
      function beat(){
        try{ localStorage.setItem(ORIS_BEAT_KEY, Date.now().toString()); }catch{}
        try{ bc && bc.postMessage('ping'); }catch{}
      }
      // ping imm√©diat au chargement + intervalle + au retour en visibilit√©
      beat();
      setInterval(beat, ORIS_BEAT_INTERVAL);
      document.addEventListener('visibilitychange', ()=>{ if(!document.hidden) beat(); });
    })();

    // ====== DATE UTILS (Europe/Paris) ======
    function startOfDay(d){ const x = new Date(d); x.setHours(0,0,0,0); return x; }
    function endOfDay(d){ const x = new Date(d); x.setHours(23,59,59,999); return x; }
    function addDays(d,n){ const x = new Date(d); x.setDate(x.getDate()+n); return x; }
    function addMonths(d,n){ const x = new Date(d); x.setMonth(x.getMonth()+n); return x; }
    function startOfWeek(d){ const x = new Date(d); const day=(x.getDay()+6)%7; x.setDate(x.getDate()-day); x.setHours(0,0,0,0); return x; } // Monday
    function endOfWeek(d){ const s = startOfWeek(d); return addDays(s,6); }
    function startOfMonth(d){ return new Date(d.getFullYear(), d.getMonth(), 1); }
    function endOfMonth(d){ return new Date(d.getFullYear(), d.getMonth()+1, 0); }
    function fmtDate(d,opts){ return d.toLocaleString('fr-FR',opts||{ day:'2-digit', month:'2-digit', year:'numeric', hour:'2-digit', minute:'2-digit' }); }
    function toDate(value){
      if(!value) return null;
      const d = new Date(value);
      return Number.isNaN(d.valueOf()) ? null : d;
    }
    const DAY_MS = 24 * 60 * 60 * 1000;
    function isSameDay(a,b){
      if(!a || !b) return false;
      return a.getFullYear()===b.getFullYear() && a.getMonth()===b.getMonth() && a.getDate()===b.getDate();
    }
    function canEventBeDragged(ev){
      return !!(ev && !ev.isSphaira && !ev.recurring && ev.id && ev.calId);
    }
    function clearDragState(){
      if(dragSourceEl){
        dragSourceEl.classList.remove('dragging');
        dragSourceEl = null;
      }
      document.querySelectorAll('.cell.drag-over').forEach(el=> el.classList.remove('drag-over'));
      draggingEvent = null;
      isDraggingEvent = false;
    }
    function setupEventInteractions(el, ev){
      if(ev.isSphaira){
        el.style.cursor = 'default';
        return;
      }
      el.onclick = (e)=>{
        if(isDraggingEvent){ e.preventDefault(); return; }
        openEventModal({ existing: ev });
      };
      if(!canEventBeDragged(ev)) return;
      el.classList.add('draggable');
      el.draggable = true;
      el.addEventListener('dragstart', (event)=>{
        if(!canEventBeDragged(ev)) return;
        draggingEvent = ev;
        dragSourceEl = el;
        isDraggingEvent = true;
        el.classList.add('dragging');
        if(event.dataTransfer){
          event.dataTransfer.effectAllowed = 'move';
          event.dataTransfer.setData('text/plain', ev.id || 'event');
        }
      });
      el.addEventListener('dragend', ()=>{
        clearDragState();
      });
    }
    function parseCellDate(cell){
      if(!cell || !cell.dataset) return null;
      const iso = cell.dataset.date;
      if(!iso) return null;
      const d = new Date(iso);
      return Number.isNaN(d.valueOf()) ? null : d;
    }
    function setupCellDropTarget(cell){
      cell.addEventListener('dragover', (e)=>{
        if(!canEventBeDragged(draggingEvent)) return;
        if(!parseCellDate(e.currentTarget)) return;
        e.preventDefault();
        if(e.dataTransfer) e.dataTransfer.dropEffect = 'move';
      });
      cell.addEventListener('dragenter', (e)=>{
        if(!canEventBeDragged(draggingEvent)) return;
        if(!parseCellDate(e.currentTarget)) return;
        e.currentTarget.classList.add('drag-over');
      });
      cell.addEventListener('dragleave', (e)=>{
        const target = e.currentTarget;
        if(!target.contains(e.relatedTarget)){
          target.classList.remove('drag-over');
        }
      });
      cell.addEventListener('drop', async (e)=>{
        if(!canEventBeDragged(draggingEvent)) return;
        const cellEl = e.currentTarget;
        const targetDate = parseCellDate(cellEl);
        cellEl.classList.remove('drag-over');
        if(!targetDate) return;
        e.preventDefault();
        const eventToMove = draggingEvent;
        clearDragState();
        if(!eventToMove) return;
        if(isSameDay(eventToMove.startDate, targetDate)) return;
        await moveEventToDate(eventToMove, targetDate);
      });
    }
    async function moveEventToDate(ev, targetDate){
      try{
        await waitForGapiReady();
        if(!window.gapi || !gapi.client || !gapi.client.calendar || !gapi.client.calendar.events){
          alert('Connectez-vous √† Google pour d√©placer un √©v√©nement.');
          return;
        }
        setStatus('D√©placement de l‚Äô√©v√©nement‚Ä¶');
        if(ev.allDay){
          const startDateStr = ev.raw?.start?.date || (ev.startRaw?.slice?.(0,10)) || toDateOnlyString(startOfDay(ev.startDate));
          const endDateStr = ev.raw?.end?.date || (ev.endRaw?.slice?.(0,10)) || toDateOnlyString(addDays(ev.startDate, 1));
          const startDate = startDateStr ? toDate(`${startDateStr}T00:00`) : startOfDay(ev.startDate);
          const endDate = endDateStr ? toDate(`${endDateStr}T00:00`) : addDays(startDate, 1);
          let durationDays = Math.max(1, Math.round((endDate - startDate) / DAY_MS));
          if(!Number.isFinite(durationDays) || durationDays < 1) durationDays = 1;
          const newStartDay = startOfDay(targetDate);
          const resource = {
            start: { date: toDateOnlyString(newStartDay) },
            end: { date: toDateOnlyString(addDays(newStartDay, durationDays)) }
          };
          await gapi.client.calendar.events.patch({ calendarId: ev.calId, eventId: ev.id, resource });
        }else{
          const startRaw = ev.raw?.start?.dateTime || ev.startRaw;
          const endRaw = ev.raw?.end?.dateTime || ev.endRaw;
          const startBase = toDate(startRaw) || ev.startDate;
          const endBase = toDate(endRaw) || ev.endDate || startBase;
          const durationMs = Math.max(0, endBase.valueOf() - startBase.valueOf());
          const newStart = new Date(targetDate);
          newStart.setHours(startBase.getHours(), startBase.getMinutes(), startBase.getSeconds(), startBase.getMilliseconds());
          const newEnd = new Date(newStart.valueOf() + durationMs);
          const resource = {
            start: { dateTime: newStart.toISOString() },
            end: { dateTime: newEnd.toISOString() }
          };
          if(ev.raw?.start?.timeZone){ resource.start.timeZone = ev.raw.start.timeZone; }
          if(ev.raw?.end?.timeZone){ resource.end.timeZone = ev.raw.end.timeZone; }
          await gapi.client.calendar.events.patch({ calendarId: ev.calId, eventId: ev.id, resource });
        }
        setStatus('√âv√©nement d√©plac√©.');
        await loadEvents();
      }catch(err){
        console.error('[ORIS] moveEventToDate error:', err);
        alert('Impossible de d√©placer cet √©v√©nement. V√©rifiez vos permissions.');
        setStatus('√âchec du d√©placement.');
      }
    }

    // ====== AUTH ======
    async function tryGoogleFromAtmos(){
      try{
        const { data } = await supabase.auth.getSession();
        const session = data?.session;
        if(!session) return false;
        const provider = session.user?.app_metadata?.provider;
        const accessToken = session.provider_token;
        if(provider === 'google' && accessToken){
          await waitForGapiReady();
          if(!window.__gapiReady){ return false; }
          gapi.client.setToken({ access_token: accessToken });
          logoutBtn.disabled = false;
          setStatus('Connect√© √† Google via ATMOS. Chargement des calendriers‚Ä¶');
          await bootCalendar();
          return true;
        }
        return false;
      }catch{ return false; }
    }

    async function ensureGsiLoaded(){
      if (window.google && google.accounts) return;
      await new Promise((resolve, reject)=>{
        const s = document.createElement('script');
        s.src = "https://accounts.google.com/gsi/client";
        s.async = true; s.defer = true;
        s.onload = resolve; s.onerror = reject;
        document.head.appendChild(s);
      });
    }

    async function loginGoogle(){
      if(document.body.classList.contains('auth-locked')){
        setStatus('Connexion √† ATMOS requise.');
        return;
      }
      await ensureGsiLoaded();
      await waitForGapiReady();
      if(!window.__gapiReady){ setStatus('Google API non pr√™te.'); return; }

      if(!googleTokenClient){
        googleTokenClient = google.accounts.oauth2.initTokenClient({
          client_id: GOOGLE_CLIENT_ID,
          scope: CAL_SCOPES,
          callback: async (resp)=>{
            if(resp && resp.access_token){
              gapi.client.setToken({ access_token: resp.access_token });
              logoutBtn.disabled = false;
              setStatus('Authentifi√©. R√©cup√©ration des calendriers‚Ä¶');
              try{
                await bootCalendar();
              }catch(err){
                console.error('[ORIS] bootCalendar after login failed:', err);
              }
            }else{
              setStatus('√âchec authentification Google.');
            }
          }
        });
      }
      googleTokenClient.requestAccessToken({ prompt:'' });
    }

    function logoutGoogle(){
      try{
        const tok = gapi.client.getToken();
        if(tok && tok.access_token){ google.accounts.oauth2.revoke(tok.access_token, ()=>{}); }
      }catch{}
      gapi.client.setToken('');
      if(refreshTimer){ clearInterval(refreshTimer); refreshTimer=null; }
      calendars=[];
      googleEvents = [];
      events=[];
      visibleCalendars = new Set();
      hasLoadedCalendars = false;
      calendarSelect.innerHTML = `<option value="">Tous les calendriers</option><option value="${SPHAIRA_CALENDAR_ID}">${SPHAIRA_CALENDAR.summary} (SPHAIRA)</option>`;
      calendarSelect.value = '';
      fCalendar.innerHTML = '';
      calListEl.innerHTML = '';
      const emptyMsg = document.createElement('div');
      emptyMsg.className = 'status';
      emptyMsg.textContent = 'Aucun calendrier Google disponible.';
      calListEl.appendChild(emptyMsg);
      calListEl.appendChild(createCalendarToggle(SPHAIRA_CALENDAR, true));
      mergeEvents();
      logoutBtn.disabled = true;
      setStatus('D√©connect√©.');
    }

    function createCalendarToggle(cal, shouldCheck){
      const item = document.createElement('label');
      item.className = 'cal-item';
      item.dataset.calendarId = cal.id;

      const toggle = document.createElement('input');
      toggle.type = 'checkbox';
      toggle.checked = shouldCheck;
      toggle.setAttribute('aria-label', cal.isSphaira ? 'Afficher les t√¢ches SPHAIRA' : `Afficher le calendrier ${cal.summary}`);

      const dot = document.createElement('span');
      dot.className = 'dot';
      dot.style.background = cal.backgroundColor || '#00EAFF';

      const text = document.createElement('div');
      const labelText = document.createElement('strong');
      labelText.textContent = cal.summary;
      text.appendChild(labelText);
      if(cal.isSphaira){
        const small = document.createElement('small');
        small.textContent = ' (SPHAIRA)';
        text.appendChild(small);
      }else if(cal.primary){
        const small = document.createElement('small');
        small.textContent = ' (principal)';
        text.appendChild(small);
      }

      if(shouldCheck){
        visibleCalendars.add(cal.id);
      }else{
        item.classList.add('cal-hidden');
      }

      toggle.addEventListener('change', ()=>{
        if(toggle.checked){
          visibleCalendars.add(cal.id);
          item.classList.remove('cal-hidden');
        }else{
          visibleCalendars.delete(cal.id);
          item.classList.add('cal-hidden');
        }
        render();
      });

      item.appendChild(toggle);
      item.appendChild(dot);
      item.appendChild(text);
      return item;
    }

    // ====== CALENDAR API ======
    async function bootCalendar(){
      try{
        await loadCalendars();
        await loadEvents();
        autoRefresh();
        setStatus('Calendriers synchronis√©s.');
      }catch(err){
        console.error('[ORIS] bootCalendar error:', err);
        throw err;
      }
    }

    async function loadCalendars(){
      const res = await gapi.client.calendar.calendarList.list({ showHidden:false, minAccessRole:'reader' });
      calendars = (res.result.items||[]).map(c=>({
        id:c.id, summary:c.summary, backgroundColor: c.backgroundColor || '#0ea5e9', primary: !!c.primary
      }));
      const previousSelectionValue = calendarSelect.value;
      const calendarsForSelect = [...calendars, SPHAIRA_CALENDAR];
      calendarSelect.innerHTML = `<option value="">Tous les calendriers</option>` +
        calendarsForSelect.map(c=>{
          const extra = c.isSphaira ? ' (SPHAIRA)' : (c.primary?' (principal)':'');
          return `<option value="${c.id}">${c.summary}${extra}</option>`;
        }).join('');
      if(calendarsForSelect.some(c=>c.id === previousSelectionValue)){
        calendarSelect.value = previousSelectionValue;
      }else{
        calendarSelect.value = '';
      }
      // modal select (Google only)
      fCalendar.innerHTML = calendars.map(c=>`<option value="${c.id}">${c.summary}${c.primary?' (principal)':''}</option>`).join('');
      // list with toggles
      const previousSelection = hasLoadedCalendars ? new Set(visibleCalendars) : null;
      visibleCalendars = new Set();
      calListEl.innerHTML = '';
      if(!calendars.length){
        const msg = document.createElement('div');
        msg.className = 'status';
        msg.textContent = 'Aucun calendrier Google disponible.';
        calListEl.appendChild(msg);
      }
      calendars.forEach(c=>{
        const shouldCheck = previousSelection ? previousSelection.has(c.id) : true;
        calListEl.appendChild(createCalendarToggle(c, shouldCheck));
      });
      const shouldShowSphaira = previousSelection ? previousSelection.has(SPHAIRA_CALENDAR_ID) : true;
      calListEl.appendChild(createCalendarToggle(SPHAIRA_CALENDAR, shouldShowSphaira));
      hasLoadedCalendars = true;
      mergeEvents();
    }

    function currentRange(){
      let start, end, label;
      if(currentView==='month'){
        start = startOfWeek(startOfMonth(cursor)); end = endOfWeek(endOfMonth(cursor));
        label = cursor.toLocaleDateString('fr-FR',{ month:'long', year:'numeric' });
      }else if(currentView==='week'){
        start = startOfWeek(cursor); end = endOfWeek(cursor);
        const a = start.toLocaleDateString('fr-FR',{ day:'2-digit', month:'short' });
        const b = end.toLocaleDateString('fr-FR',{ day:'2-digit', month:'short', year:'numeric' });
        label = `Semaine ${a} ‚Äì ${b}`;
      }else{
        start = startOfDay(cursor); end = endOfDay(cursor);
        label = cursor.toLocaleDateString('fr-FR',{ weekday:'long', day:'numeric', month:'long', year:'numeric' });
      }
      return { start, end, label };
    }

    function mergeEvents(){
      const { label } = currentRange();
      periodLabel.textContent = label;
      const sel = calendarSelect.value;
      if(sel === SPHAIRA_CALENDAR_ID){
        events = sphairaEvents.slice();
      }else if(sel){
        events = googleEvents.slice();
      }else{
        events = googleEvents.slice();
        if(sphairaEvents.length){
          events = events.concat(sphairaEvents);
        }
        if(!googleEvents.length){
          events = sphairaEvents.slice();
        }
      }
      render();
    }

    async function loadEvents(){
      try{
        const { start, end, label } = currentRange();
        periodLabel.textContent = label;

        if(calendarSelect.value === SPHAIRA_CALENDAR_ID){
          googleEvents = [];
          mergeEvents();
          return;
        }

        const hasCalendarApi = window.gapi && gapi.client && gapi.client.calendar && gapi.client.calendar.events;
        if(!hasCalendarApi){
          googleEvents = [];
          mergeEvents();
          return;
        }

        const params = {
          calendarId: 'primary', // we‚Äôll loop later
          timeMin: start.toISOString(),
          timeMax: end.toISOString(),
          singleEvents: true,
          orderBy: 'startTime',
          maxResults: 2500
        };

        const sel = calendarSelect.value;
        let evts = [];

        const calendarsToQuery = sel ? calendars.filter(c=>c.id===sel) : calendars;
        if(!calendarsToQuery.length){
          googleEvents = [];
          mergeEvents();
          return;
        }
        for(const cal of calendarsToQuery){
          const r = await gapi.client.calendar.events.list({ ...params, calendarId: cal.id });
          const items = (r.result.items||[]).map(e=>{
          const startRaw = e.start?.dateTime || e.start?.date;
          const endRaw = e.end?.dateTime || e.end?.date || startRaw;
          const allDay = !!e.start?.date && !e.start?.dateTime;
          const startDate = toDate(startRaw) || new Date();
          const endDateRaw = toDate(endRaw) || startDate;
          const displayEnd = allDay
            ? (endDateRaw > startDate ? addDays(endDateRaw, -1) : startDate)
            : endDateRaw;
          return {
            id:e.id,
            calId:cal.id,
            calName:cal.summary,
            color: cal.backgroundColor,
            summary:e.summary||'(Sans titre)',
            location:e.location||'',
            description:e.description||'',
            startRaw,
            endRaw,
            startDate,
            endDate: displayEnd,
            allDay,
            hangoutLink: e.hangoutLink || '',
            recurring: !!e.recurrence?.length,
            raw:e,
            isSphaira:false
          };
        });
          evts.push(...items);
        }
        googleEvents = evts;
        mergeEvents();
      }catch(err){
        console.error('[ORIS] loadEvents error:', err);
        setStatus('Erreur lors du chargement des √©v√©nements.');
        throw err;
      }
    }

    async function saveEvent(data){
      // data: {id?, calId, summary, description, location, startISO?, endISO?, startDate?, endDate?, allDay, meet:'create'|''}
      const resource = composeEventResource(data);
      if(data.id){
        const res = await gapi.client.calendar.events.patch({
          calendarId: data.calId,
          eventId: data.id,
          resource
        });
        return res.result;
      }
      const params = {
        calendarId: data.calId,
        resource
      };
      if(data.meet === 'create'){
        params.conferenceDataVersion = 1;
      }
      const res = await gapi.client.calendar.events.insert(params);
      return res.result;
    }

    function composeEventResource(d){
      const body = {
        summary: d.summary || '(Sans titre)',
        description: d.description || '',
        location: d.location || ''
      };
      if(d.allDay){
        body.start = { date: d.startDate };
        body.end = { date: d.endDate };
      }else{
        body.start = { dateTime: d.startISO };
        body.end = { dateTime: d.endISO };
      }
      if(d.meet==='create'){
        body.conferenceData = {
          createRequest: {
            requestId: 'meet-'+Math.random().toString(36).slice(2),
            conferenceSolutionKey: { type:'hangoutsMeet' }
          }
        };
      }
      return body;
    }

    async function deleteEvent(calId, id){
      await gapi.client.calendar.events.delete({ calendarId: calId, eventId: id });
    }

    // ====== RENDER ======
    function render(){
      const { start, end } = currentRange();
      const activeEvents = hasLoadedCalendars ? events.filter(ev=>visibleCalendars.has(ev.calId)) : events.slice();
      if(hasLoadedCalendars && calendars.length === 0){
        gridEl.className = 'grid day';
        gridEl.innerHTML = '';
        const message = document.createElement('div');
        message.className = 'cell';
        message.style.gridColumn = '1 / -1';
        message.style.minHeight = '200px';
        message.style.display = 'flex';
        message.style.alignItems = 'center';
        message.style.justifyContent = 'center';
        message.innerHTML = '<div class="status">Aucun calendrier disponible.</div>';
        gridEl.appendChild(message);
        return;
      }
      if(hasLoadedCalendars && visibleCalendars.size === 0){
        gridEl.className = 'grid day';
        gridEl.innerHTML = '';
        const message = document.createElement('div');
        message.className = 'cell';
        message.style.gridColumn = '1 / -1';
        message.style.minHeight = '200px';
        message.style.display = 'flex';
        message.style.alignItems = 'center';
        message.style.justifyContent = 'center';
        message.innerHTML = '<div class="status">S√©lectionnez un calendrier √† afficher.</div>';
        gridEl.appendChild(message);
        return;
      }

      gridEl.className = 'grid ' + currentView;
      gridEl.innerHTML = '';

      if(currentView==='month'){
        // headers
        ['Lun','Mar','Mer','Jeu','Ven','Sam','Dim'].forEach(d=>{
          const h = document.createElement('div'); h.className='cell head'; h.textContent = d; gridEl.appendChild(h);
        });
        const first = start; const days = Math.round((end-first)/(86400000))+1;
        for(let i=0;i<days;i++){
          const day = addDays(first,i);
          const cell = document.createElement('div'); cell.className='cell'; cell.dataset.date = day.toISOString();
          setupCellDropTarget(cell);
          const head = document.createElement('div'); head.style.display='flex'; head.style.justifyContent='space-between'; head.style.alignItems='center';
          head.innerHTML = `<strong>${day.getDate()}</strong>`;
          const plus = document.createElement('button'); plus.className='btn small'; plus.textContent='+'; plus.title='Nouvel √©v√©nement';
          plus.onclick = (e)=>{ e.stopPropagation(); openEventModal({ start: day, end: addDays(day,1), allDay:true }); };
          head.appendChild(plus);
          cell.appendChild(head);

          const list = document.createElement('div');
          activeEvents.filter(ev=>{
            const s = ev.startDate;
            const e = ev.endDate || ev.startDate;
            const d0 = startOfDay(day);
            return s <= endOfDay(day) && e >= d0; // overlap day
          }).slice(0,5).forEach(ev=>{
            const div = document.createElement('div'); div.className='event';
            const when = ev.allDay ? 'Journ√©e' : `${ev.startDate.toLocaleTimeString('fr-FR',{hour:'2-digit',minute:'2-digit'})}`;
            div.innerHTML = `<div style="display:flex; gap:6px; align-items:center"><span class="dot" style="background:${ev.color}"></span><strong>${escapeHtml(ev.summary)}</strong></div><div class="when">${when} ‚Äî ${escapeHtml(ev.calName)}</div>`;
            setupEventInteractions(div, ev);
            list.appendChild(div);
          });
          cell.appendChild(list);
          gridEl.appendChild(cell);
        }
      }

      if(currentView==='week'){
        // header row
        const head0 = document.createElement('div'); head0.className='cell head'; head0.textContent='Heure'; gridEl.appendChild(head0);
        for(let i=0;i<7;i++){
          const d = addDays(startOfWeek(cursor), i);
          const h = document.createElement('div'); h.className='cell head'; h.innerHTML = d.toLocaleDateString('fr-FR',{weekday:'short', day:'2-digit', month:'2-digit'});
          gridEl.appendChild(h);
        }
        // body: simple lists by day
        for(let row=0; row<12; row++){
          const hourLabel = document.createElement('div'); hourLabel.className='cell head'; hourLabel.textContent = (row*2).toString().padStart(2,'0')+':00';
          gridEl.appendChild(hourLabel);
          for(let i=0;i<7;i++){
            const d = addDays(startOfWeek(cursor), i);
            const cell = document.createElement('div'); cell.className='cell'; cell.dataset.date = d.toISOString();
            setupCellDropTarget(cell);
            const plus = document.createElement('button'); plus.className='btn small'; plus.textContent='+'; plus.title='Nouvel √©v√©nement';
            plus.onclick = (e)=>{ e.stopPropagation(); openEventModal({ start: new Date(d.getFullYear(), d.getMonth(), d.getDate(), row*2), end: new Date(d.getFullYear(), d.getMonth(), d.getDate(), row*2+1) }); };
            cell.appendChild(plus);
            activeEvents.filter(ev=>{
              const s = ev.startDate; const e = ev.endDate || ev.startDate;
              return s <= endOfDay(d) && e >= startOfDay(d);
            }).slice(0,4).forEach(ev=>{
              const div=document.createElement('div'); div.className='event';
              const when = ev.allDay ? 'Journ√©e' : `${ev.startDate.toLocaleTimeString('fr-FR',{hour:'2-digit',minute:'2-digit'})}`;
              div.innerHTML = `<div style="display:flex;gap:6px;align-items:center"><span class="dot" style="background:${ev.color}"></span><strong>${escapeHtml(ev.summary)}</strong></div><div class="when">${when} ‚Äî ${escapeHtml(ev.calName)}</div>`;
              setupEventInteractions(div, ev);
              cell.appendChild(div);
            });
            gridEl.appendChild(cell);
          }
        }
      }

      if(currentView==='day'){
        const d = cursor;
        const head = document.createElement('div'); head.className='cell head'; head.textContent = d.toLocaleDateString('fr-FR',{weekday:'long', day:'numeric', month:'long', year:'numeric'});
        gridEl.appendChild(head);
        const cell = document.createElement('div'); cell.className='cell';
        cell.dataset.date = startOfDay(d).toISOString();
        setupCellDropTarget(cell);
        const plus = document.createElement('button'); plus.className='btn small'; plus.textContent='+'; plus.title='Nouvel √©v√©nement';
        plus.onclick = ()=> openEventModal({ start: d, end: addDays(d,0), allDay:false });
        cell.appendChild(plus);
        activeEvents.filter(ev=>{
          const s = ev.startDate; const e = ev.endDate || ev.startDate;
          return s <= endOfDay(d) && e >= startOfDay(d);
        }).forEach(ev=>{
          const div=document.createElement('div'); div.className='event';
          const endDisplay = ev.endDate || ev.startDate;
          const when = ev.allDay ? 'Journ√©e' : `${ev.startDate.toLocaleTimeString('fr-FR',{hour:'2-digit',minute:'2-digit'})} ‚Üí ${endDisplay.toLocaleTimeString('fr-FR',{hour:'2-digit',minute:'2-digit'})}`;
          div.innerHTML = `<div style="display:flex;gap:6px;align-items:center"><span class="dot" style="background:${ev.color}"></span><strong>${escapeHtml(ev.summary)}</strong></div><div class="when">${when} ‚Äî ${escapeHtml(ev.calName)}</div>${ev.location?`<div class="when">üìç ${escapeHtml(ev.location)}</div>`:''}`;
          setupEventInteractions(div, ev);
          cell.appendChild(div);
        });
        gridEl.appendChild(cell);
      }
    }

    function escapeHtml(s){ return String(s||'').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

    // ====== EVENT MODAL ======
    function openEventModal({ existing=null, start=null, end=null, allDay=false }){
      currentEvent = existing;
      evtTitle.textContent = existing ? 'Modifier l‚Äô√©v√©nement' : 'Nouvel √©v√©nement';
      deleteEventBtn.style.display = existing ? '' : 'none';

      // calendars select
      fCalendar.innerHTML = calendars.map(c=>`<option value="${c.id}">${c.summary}${c.primary?' (principal)':''}</option>`).join('');

      if(existing){
        fTitle.value = existing.summary || '';
        fCalendar.value = existing.calId;
        if(existing.allDay){
          const s = toDate(`${existing.startRaw}T00:00`) || new Date();
          const exclusiveEnd = toDate(`${(existing.endRaw || existing.startRaw)}T00:00`);
          const inclusiveEnd = exclusiveEnd ? addDays(exclusiveEnd, -1) : s;
          fStart.value = toLocalInputValue(s, false);
          fEnd.value = toLocalInputValue(inclusiveEnd, false);
        }else{
          const s = toDate(existing.startRaw) || new Date();
          const e = toDate(existing.endRaw || existing.startRaw) || s;
          fStart.value = toLocalInputValue(s, true);
          fEnd.value = toLocalInputValue(e, true);
        }
        fLocation.value = existing.location || '';
        fDesc.value = existing.description || '';
        fMeet.value = existing.raw.conferenceData?.entryPoints?.length ? '' : '';
      }else{
        fTitle.value = '';
        fCalendar.value = (calendars.find(c=>c.primary)?.id) || calendars[0]?.id || '';
        const s = start || new Date();
        fStart.value = toLocalInputValue(s, !allDay);
        if(allDay){
          const endCandidate = end ? addDays(end, -1) : s;
          fEnd.value = toLocalInputValue(endCandidate, false);
        }else{
          const endCandidate = end || addMinutes(s,60);
          fEnd.value = toLocalInputValue(endCandidate, true);
        }
        fLocation.value = '';
        fDesc.value = '';
        fMeet.value = '';
      }

      eventModal.style.display = 'flex';
      eventModal.setAttribute('aria-hidden','false');
    }
    function closeEventModal(){
      eventModal.style.display='none';
      eventModal.setAttribute('aria-hidden','true');
      currentEvent = null;
    }
    function addMinutes(d,m){ const x=new Date(d); x.setMinutes(x.getMinutes()+m); return x; }
    function toLocalInputValue(d, withTime){
      const pad = (n)=> String(n).padStart(2,'0');
      const yyyy = d.getFullYear(), mm = pad(d.getMonth()+1), dd = pad(d.getDate());
      if(!withTime) return `${yyyy}-${mm}-${dd}T00:00`;
      const hh = pad(d.getHours()), mi = pad(d.getMinutes());
      return `${yyyy}-${mm}-${dd}T${hh}:${mi}`;
    }
    function toDateOnlyString(d){
      const pad = (n)=> String(n).padStart(2,'0');
      return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`;
    }

    saveEventBtn.onclick = async ()=>{
      try{
        const startValue = fStart.value;
        const endValue = fEnd.value;
        if(!startValue || !endValue){ alert('Veuillez renseigner des dates de d√©but et de fin.'); return; }
        const allDay = startValue.slice(11) === '00:00' && endValue.slice(11) === '00:00';
        const base = {
          id: currentEvent?.id || null,
          calId: fCalendar.value,
          summary: fTitle.value.trim(),
          description: fDesc.value,
          location: fLocation.value,
          allDay,
          meet: fMeet.value
        };
        if(allDay){
          const startDateStr = startValue.slice(0,10);
          const endDateStr = endValue.slice(0,10);
          if(!startDateStr || !endDateStr){ alert('Format de date invalide.'); return; }
          const startDay = toDate(`${startDateStr}T00:00`);
          const endDay = toDate(`${endDateStr}T00:00`);
          if(!startDay || !endDay){ alert('Format de date invalide.'); return; }
          if(endDay < startDay){ alert('La date de fin ne peut pas √™tre ant√©rieure √† la date de d√©but.'); return; }
          base.startDate = toDateOnlyString(startDay);
          base.endDate = toDateOnlyString(addDays(endDay, 1));
        }else{
          const start = toDate(startValue);
          const end = toDate(endValue);
          if(!start || !end){ alert('Dates/heures invalides.'); return; }
          if(end <= start){ alert('La date de fin doit √™tre post√©rieure √† la date de d√©but.'); return; }
          base.startISO = start.toISOString();
          base.endISO = end.toISOString();
        }
        await saveEvent(base);
        closeEventModal();
        setStatus('√âv√©nement enregistr√©.');
        await loadEvents();
      }catch(e){ console.error(e); alert('√âchec enregistrement (permissions ?).'); }
    };
    deleteEventBtn.onclick = async ()=>{
      if(!currentEvent) return;
      if(!confirm('Supprimer cet √©v√©nement ?')) return;
      try{
        await deleteEvent(currentEvent.calId, currentEvent.id);
        closeEventModal();
        setStatus('√âv√©nement supprim√©.');
        await loadEvents();
      }catch(e){ console.error(e); alert('√âchec suppression.'); }
    };
    closeEventBtn.onclick = closeEventModal;

    // ====== TASKS (SPHAIRA) ======
    const STORAGE_KEYS = [
      'sphaira:workspaceState:v1',
      'sphaira:workspaceState:v2',
      'workspaceState',
      'sphaira:tasks',
      'sphaira:tasks:v1'
    ];
    function loadWorkspaceFromStorage(){
      for(const key of STORAGE_KEYS){
        try{
          const raw = localStorage.getItem(key);
          if(raw){ const json=JSON.parse(raw); return { json, storageKey:key }; }
        }catch(e){}
      }
      return { json:null, storageKey:null };
    }
    function normalizeTask(task, meta={}){
      const title = task?.title || task?.name || '(Sans titre)';
      const desc = task?.desc || task?.description || '';
      const start = task?.start || task?.startDate || task?.dueDate || '';
      const end = task?.end || task?.endDate || '';
      const status = task?.status || meta.status || '';
      return {
        id: task?.id || `${meta.prefix||'task'}-${Math.random().toString(36).slice(2,9)}`,
        title,
        desc,
        start,
        end,
        status,
        nodeName: meta.nodeName || '',
        color: task?.color || meta.color || '#00EAFF'
      };
    }
    function extractTasks(ws){
      if(!ws) return [];
      const tasks=[];
      const pushTasks = (list=[], meta={})=>{
        list.filter(Boolean).forEach(t=> tasks.push(normalizeTask(t, meta)));
      };
      if(Array.isArray(ws)){
        pushTasks(ws);
      }
      if(Array.isArray(ws.tasks)){
        pushTasks(ws.tasks);
      }
      if(Array.isArray(ws.nodes)){
        const nodes = Object.fromEntries(ws.nodes.map(n=>[n.id, {
          name:n.text||n.title||n.id,
          color:n.color||'#00EAFF'
        }]));
        ws.nodes.forEach(n=>{
          const meta = {
            nodeName: nodes[n.id]?.name || n.id,
            color: nodes[n.id]?.color || '#00EAFF',
            prefix: `node-${n.id}`
          };
          pushTasks(n.tasks || [], meta);
        });
      }
      const collections = ['columns','lists'];
      collections.forEach(key=>{
        if(Array.isArray(ws[key])){
          ws[key].forEach(col=>{
            const meta = {
              nodeName: col.name || col.title || '',
              color: col.color || '#00EAFF',
              status: col.status || col.name || '',
              prefix: `${key}-${col.id||col.name||'col'}`
            };
            pushTasks(col.tasks || col.cards || [], meta);
          });
        }
      });
      if(Array.isArray(ws.boards)){
        ws.boards.forEach(board=>{
          pushTasks(board.tasks || [], {
            nodeName: board.name || board.title || '',
            color: board.color || '#00EAFF',
            prefix: `board-${board.id||board.name||'board'}`
          });
          collections.forEach(key=>{
            if(Array.isArray(board[key])){
              board[key].forEach(col=>{
                const meta = {
                  nodeName: col.name || col.title || board.name || '',
                  color: col.color || board.color || '#00EAFF',
                  status: col.status || col.name || '',
                  prefix: `${key}-${board.id||board.name||'board'}-${col.id||col.name||'col'}`
                };
                pushTasks(col.tasks || col.cards || [], meta);
              });
            }
          });
        });
      }
      return tasks;
    }
    function taskToEvent(task){
      const startCandidate = toDate(task.start) || toDate(task.end);
      if(!startCandidate) return null;
      const endCandidate = toDate(task.end) || startCandidate;
      const hasTimeInfo = (task.start && task.start.includes('T')) || (task.end && task.end.includes('T'));
      const allDay = !hasTimeInfo;
      const startDate = allDay ? startOfDay(startCandidate) : startCandidate;
      let endDateRaw = allDay ? startOfDay(addDays(endCandidate, 1)) : endCandidate;
      if(allDay && endDateRaw <= startDate){ endDateRaw = addDays(startDate, 1); }
      if(!allDay && endDateRaw < startDate){ endDateRaw = startDate; }
      const displayEnd = allDay ? addDays(endDateRaw, -1) : endDateRaw;
      const startRaw = allDay ? toDateOnlyString(startDate) : startDate.toISOString();
      const endRaw = allDay ? toDateOnlyString(endDateRaw) : endDateRaw.toISOString();
      const context = ['T√¢ches SPHAIRA'];
      if(task.nodeName){ context.push(task.nodeName); }
      if(task.status){ context.push(task.status); }
      return {
        id: task.id,
        calId: SPHAIRA_CALENDAR_ID,
        calName: context.join(' ¬∑ '),
        color: task.color || SPHAIRA_CALENDAR.backgroundColor,
        summary: task.title || '(Sans titre)',
        location: '',
        description: task.desc || '',
        startRaw,
        endRaw,
        startDate,
        endDate: displayEnd,
        allDay,
        hangoutLink: '',
        recurring: false,
        isSphaira: true,
        raw: { task }
      };
    }
    function renderTasks(){
      const { json } = loadWorkspaceFromStorage();
      const list = json ? extractTasks(json) : [];
      list.sort((a,b)=> (a.start||'').localeCompare(b.start||'') || a.title.localeCompare(b.title));
      sphairaEvents = list.map(taskToEvent).filter(Boolean);

      if(!calendarSelect.querySelector(`option[value="${SPHAIRA_CALENDAR_ID}"]`)){
        const opt = document.createElement('option');
        opt.value = SPHAIRA_CALENDAR_ID;
        opt.textContent = `${SPHAIRA_CALENDAR.summary} (SPHAIRA)`;
        calendarSelect.appendChild(opt);
      }
      if(!calListEl.querySelector(`.cal-item[data-calendar-id="${SPHAIRA_CALENDAR_ID}"]`)){
        calListEl.appendChild(createCalendarToggle(SPHAIRA_CALENDAR, true));
      }

      if(!list.length){
        taskListEl.innerHTML = '<div class="status">Aucune t√¢che trouv√©e.</div>';
      }else{
        taskListEl.innerHTML = '';
        list.forEach(t=>{
          const el = document.createElement('div');
          el.className='task';
          el.innerHTML = `<span class="dot" style="background:${t.color}"></span>
            <div>
              <div><strong>${escapeHtml(t.title)}</strong></div>
              ${t.status ? `<small>Statut : ${escapeHtml(t.status)}</small><br/>` : ''}
              ${t.start || t.end ? `<small>${t.start ? 'Du '+escapeHtml(t.start) : ''} ${t.end ? ' au '+escapeHtml(t.end) : ''}</small><br/>` : ''}
              ${t.nodeName ? `<small>Sur : ${escapeHtml(t.nodeName)}</small>`:''}
              ${t.desc ? `<div style="margin-top:6px">${escapeHtml(t.desc)}</div>`:''}
            </div>`;
          taskListEl.appendChild(el);
        });
      }
      mergeEvents();
    }
    toggleTasksBtn.onclick = ()=>{
      const hidden = tasksSection.style.display === 'none';
      tasksSection.style.display = hidden ? '' : 'none';
    }; // simple toggle
    window.addEventListener('storage', (e)=>{ if(STORAGE_KEYS.includes(e.key)) renderTasks(); });

    // ====== NAV + SEARCH ======
    prevBtn.onclick = async ()=>{ cursor = currentView==='month' ? addMonths(cursor, -1) : addDays(cursor, currentView==='week'?-7:-1); await loadEvents(); };
    nextBtn.onclick = async ()=>{ cursor = currentView==='month' ? addMonths(cursor, +1) : addDays(cursor, currentView==='week'?+7:+1); await loadEvents(); };
    todayBtn.onclick = async ()=>{ cursor = new Date(); await loadEvents(); };
    viewBtns.forEach(b=> b.onclick = async ()=>{
      viewBtns.forEach(x=>x.classList.remove('active'));
      b.classList.add('active'); currentView = b.dataset.view; await loadEvents();
    });
    searchBtn.onclick = ()=> {
      const q = searchInput.value.trim().toLowerCase();
      if(!q){
        render();
        return;
      }
      const filtered = events.filter(e=>{
        if(hasLoadedCalendars && !visibleCalendars.has(e.calId)) return false;
        const summary = (e.summary||'').toLowerCase();
        const location = (e.location||'').toLowerCase();
        const description = (e.description||'').toLowerCase();
        return summary.includes(q) || location.includes(q) || description.includes(q);
      });
      const keep = events; events = filtered; render(); events = keep; // render filtered once
    };
    calendarSelect.onchange = async ()=>{
      const sel = calendarSelect.value;
      if(sel && hasLoadedCalendars && !visibleCalendars.has(sel)){
        visibleCalendars.add(sel);
        const item = Array.from(calListEl.querySelectorAll('.cal-item')).find(el=>el.dataset.calendarId === sel);
        if(item){
          const toggle = item.querySelector('input[type="checkbox"]');
          if(toggle) toggle.checked = true;
          item.classList.remove('cal-hidden');
        }
      }
      await loadEvents();
    };
    refreshBtn.onclick = loadEvents;

    // ====== AUTO REFRESH ======
    let refreshTimer=null;
    function autoRefresh(){
      if(refreshTimer) clearInterval(refreshTimer);
      refreshTimer = setInterval(()=>{ loadEvents().catch(()=>{}); }, 60_000); // 60s
    }

    // ====== BOOT ======
    function bindAuth(){
      googleBtn.onclick = loginGoogle;
      logoutBtn.onclick = logoutGoogle;
    }
    bindAuth();

    async function checkAuth(){
      const { data } = await supabase.auth.getSession();
      setAuthLocked(!data?.session);
      if(data?.session){
        const ok = await tryGoogleFromAtmos();
        if(!ok){ setStatus('Session ATMOS active : cliquez ¬´ Connecter Google ¬ª.'); }
      }
    }
    supabase.auth.onAuthStateChange(async (_evt, session) => {
      setAuthLocked(!session);
      if(session){ await tryGoogleFromAtmos(); }
    });

    // initial
    checkAuth();
    renderTasks();
    if (location.protocol === "file:") {
      console.warn("‚ö†Ô∏è Ouvre via HTTPS (ou un serveur local) pour l‚Äôauth Google.");
    }
  </script>
</body>
</html>
